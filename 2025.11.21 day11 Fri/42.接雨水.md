# [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)





给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```

 

**提示：**

- `n == height.length`
- `1 <= n <= 2 * 104`
- `0 <= height[i] <= 105`



- 一拿到这道题，怎么看？

  把柱子画成图，一眼就能看出“凹槽”里能存水。  
  存水的量 = 凹槽左右两边较矮的那根柱子（短板）的高度 − 当前凹槽底部的高度。  
  所以核心问题变成：对每一根柱子，快速知道它左边最高的柱子、右边最高的柱子，二者取小，再减去自身高度，就是这根柱子上方能接住的水量。

  ---

  ### 暴力算法（Brute Force）

  对每一根柱子 `i`：

  1. 往左扫一遍，找左边最大值 `leftMax`。  
  2. 往右扫一遍，找右边最大值 `rightMax`。  
  3. 水量 `+= max(0, min(leftMax, rightMax) - height[i])`。

  时间复杂度：O(n²)  
  空间复杂度：O(1)

  ---

  ### 下意识能想到的优化

  “左边最大值”和“右边最大值”其实可以预先一次性算出来，用两个数组存好，后面直接查表。  
  这就是“动态规划预处理左右最大值”的做法。

  ---

  ### 最优算法（双指针一次遍历）

  观察发现：  
  - 如果左边整体“矮”，那么左边最大值已知，右边最大值无论多大，都不影响当前水量（因为短板在左边）。  
  - 反之，右边整体“矮”，同理。  

  因此用两根指针从两端向中间走，边走边更新左右最大值，能当场算出当前指针位置的水量，无需额外数组。

  时间复杂度：O(n)  
  空间复杂度：O(1)——最优。

  ---

  ### 最优算法代码（逐行中文注释）

  ```javascript
  /**
   * @param {number[]} height
   * @return {number}
   */
  var trap = function(height) {
      if (!height || height.length < 3) return 0; // 少于 3 根柱子形不成凹槽
  
      let left = 0;                    // 左指针
      let right = height.length - 1;   // 右指针
      let leftMax = 0;                 // 目前遇到的左边最高柱子
      let rightMax = 0;                // 目前遇到的右边最高柱子
      let water = 0;                   // 接雨水总量
  
      while (left < right) {
          // 更新左右最大值
          leftMax = Math.max(leftMax, height[left]);
          rightMax = Math.max(rightMax, height[right]);
  
          // 选“矮”的一边，计算当前指针位置的水量
          if (leftMax < rightMax) {
              // 短板在左边，左边指针位置的水量已确定
              water += leftMax - height[left];
              left++;                  // 左指针右移
          } else {
              // 短板在右边，右边指针位置的水量已确定
              water += rightMax - height[right];
              right--;                 // 右指针左移
          }
      }
  
      return water;
  };
  ```

  ---

  ### 逐行解读（再总结一遍）

  1. 特判：少于 3 根柱子直接返回 0。  
  2. 双指针初始化：一个在头，一个在尾。  
  3. `leftMax` / `rightMax` 记录“一路走来”遇到的最高柱子。  
  4. 每次循环：  
     - 先更新各自最大值；  
     - 比较两边最大值，矮的那边就是“短板”，当前指针处的水量 = 短板高度 − 当前柱子高度；  
     - 把水量累加，指针向中间移动。  
  5. 两指针相遇时，所有柱子都处理完毕，返回 `water`。

  这样只扫一遍，空间 O(1)，时间 O(n)，就是面试/竞赛里要的标准答案。