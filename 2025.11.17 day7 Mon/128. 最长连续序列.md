**解题思路**

最直观的暴力做法是先把数组排序，再扫描一次得到最长的连续段。  
但排序的时间复杂度是 `O(n log n)`，不满足题目要求的 `O(n)`。

我们要在 **不排序** 的前提下，只遍历一次数组就能确定每个数是否属于某个连续序列的「开头」。

关键观察：

* 若 `x-1` 在数组中，则 `x` 一定不是某段连续序列的**第一个**元素（它前面还有更小的数）。
* 只有当 `x-1` **不在**数组时，`x` 才可能是某段连续序列的起点。

利用哈希集合 `set`（或 `unordered_set`）可以把查找时间做到 `O(1)`，整体流程如下：

1. 把所有数字放入集合 `num_set`（去重），这一步是 `O(n)`。
2. 遍历集合中的每个数 `num`：
   - 如果 `num-1` 不在 `num_set` 中，说明 `num` 是一个潜在的起始点。
   - 从 `num` 开始向后计数：`num+1`、`num+2` … 只要仍在集合中就累加计数。
   - 记录下最大的计数即为答案。

因为每个数只会被「向后遍历」一次（当它作为起点时），整体时间复杂度是 `O(n)`，空间复杂度是 `O(n)`（集合本身）。

---

#### 伪代码

```
function longestConsecutive(nums):
    if nums is empty: return 0

    num_set = set(nums)          // O(n)
    longest = 0

    for each num in num_set:     // 遍历一次，O(n)
        if (num - 1) not in num_set:   // 只处理可能的起点
            current = num
            streak = 1
            while (current + 1) in num_set:
                current += 1
                streak += 1
            longest = max(longest, streak)

    return longest
```

---

#### 完整代码（Python 3）

```python
from typing import List

class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        """
        找到未排序整数数组中最长连续数字序列的长度。
        时间复杂度：O(n)
        空间复杂度：O(n)
        """
        if not nums:
            return 0

        # 1. 用集合存储所有数字，查找 O(1)
        num_set = set(nums)

        longest = 0

        # 2. 遍历每个数字，寻找可能的起点
        for num in num_set:
            # 如果 num-1 存在，则 num 不是起点，跳过
            if num - 1 not in num_set:
                current = num
                cur_streak = 1

                # 3. 向后累计连续数字的个数
                while current + 1 in num_set:
                    current += 1
                    cur_streak += 1

                # 更新最大值
                longest = max(longest, cur_streak)

        return longest

# ------------------- 测试用例 -------------------
if __name__ == "__main__":
    sol = Solution()
    print(sol.longestConsecutive([100, 4, 200, 1, 3, 2]))  # 4
    print(sol.longestConsecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]))  # 9
    print(sol.longestConsecutive([1, 0, 1, 2]))  # 3
    print(sol.longestConsecutive([]))  # 0
    print(sol.longestConsecutive([1]))  # 1
```

---

#### 复杂度分析

| 步骤               | 时间                          | 空间                 |
| ------------------ | ----------------------------- | -------------------- |
| 构建集合 `num_set` | `O(n)`                        | `O(n)`               |
| 遍历集合并向后计数 | 每个数最多被访问一次 → `O(n)` | `O(1)`（仅若干变量） |
| **总计**           | **`O(n)`**                    | **`O(n)`**           |

这样我们就实现了在 **线性时间** 内解决「最长连续序列」问题的算法，满足题目要求。