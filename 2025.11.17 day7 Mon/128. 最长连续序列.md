# [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)



给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

 

**示例 1：**

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**示例 2：**

```
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```

**示例 3：**

```
输入：nums = [1,0,1,2]
输出：3
```



# 128. 最长连续序列 - 面试准备手册

## 📋 题目核心信息

```markdown
输入：未排序整数数组 nums
输出：最长连续数字序列的长度
约束：必须实现 O(n) 时间复杂度
关键：序列元素不要求在原数组中连续
```

---

## 👀 面试审题要点（30秒抓住关键）

| 关键词             | 含义               | 算法启示              |
| ------------------ | ------------------ | --------------------- |
| **未排序**         | 不能用排序         | 排除 sort()           |
| **O(n)要求**       | 每个元素访问常数次 | 必须用哈希表          |
| **数字连续**       | 数值相邻 (+1)      | 只需要 Set 查 `num+1` |
| **不要求位置连续** | 只看值，不看下标   | 无需考虑数组索引      |

**面试时默念**："O(n) = Set + 只处理序列起点"

---

## 💡 算法思路演进（面试话术）

### 1. 暴力尝试（向面试官展示思考过程）
"最直观的是排序后遍历，但那是 O(nlogn)。或者用双重循环对每个数左右搜索，但会到 O(n²)。"

### 2. 优化方向（关键转折点）
"我们可以用 Set 实现 O(1) 查找，但难点在于避免重复计算。如果直接遍历原数组，每个元素都尝试扩展，序列 [1,2,3,4] 会被处理 4 次。"

### 3. 最优突破（体现算法洞察力）
**核心洞察**：**只对序列起点扩展**
> "一个序列的起点满足 `num-1` 不在数组中。这样每个序列只处理一次，整体 O(n)。"

---

## ✍️ 面试手写代码模板

### 带注释版（思考时写）

```javascript
var longestConsecutive = function(nums) {
    // 1. 边界处理
    if (nums.length === 0) return 0;
    
    // 2. 用Set存所有数字，O(1)查找
    const numSet = new Set(nums);
    let maxLength = 0;
    
    // 3. 遍历Set（非原数组，避免重复）
    for (const num of numSet) {
        
        // 4. 关键：只处理序列起点
        if (!numSet.has(num - 1)) {
            
            // 5. 从起点开始扩展
            let currentNum = num;
            let currentLength = 1;
            
            // 6. 连续+1，直到找不到
            while (numSet.has(currentNum + 1)) {
                currentNum++;
                currentLength++;
            }
            
            // 7. 更新最大值
            maxLength = Math.max(maxLength, currentLength);
        }
    }
    
    return maxLength;
};
```

### 无注释版（最终提交）

```javascript
var longestConsecutive = function(nums) {
    if (nums.length === 0) return 0;
    
    const numSet = new Set(nums);
    let maxLength = 0;
    
    for (const num of numSet) {
        if (!numSet.has(num - 1)) {
            let currentNum = num;
            let currentLength = 1;
            
            while (numSet.has(currentNum + 1)) {
                currentNum++;
                currentLength++;
            }
            
            maxLength = Math.max(maxLength, currentLength);
        }
    }
    
    return maxLength;
};
```

---

## 📊 复杂度分析（面试必问）

| 项目     | 分析 | 面试话术                                                     |
| -------- | ---- | ------------------------------------------------------------ |
| **时间** | O(n) | "每个数字最多被访问2次，外层Set遍历1次，内层while对每个序列只执行1次" |
| **空间** | O(n) | "使用了Set存储所有数字，额外空间与输入规模线性相关"          |

---

## ⚠️ 面试手写避坑指南

**容易错的3个地方**：
1. **遍历对象**：必须写 `for (const num of numSet)` 而不是 `nums`
2. **起点判断**：必须检查 `num - 1` 不存在，否则复杂度退化
3. **长度初始化**：`currentLength = 1` 别写成 0

**面试时边写边解释**：
> "这里遍历Set是为了避免处理重复元素...这里是关键判断，确保只在序列最小值时启动扩展..."

---

## ✅ 自我检查 To-Do List

### 理解层面
- [ ] 能不看资料说出题目3个核心关键词
- [ ] 能解释为什么不能用排序
- [ ] 能画图说明"序列起点"的判断逻辑

### 代码层面
- [ ] 能手写完整代码，不出语法错误
- [ ] 能准确说出每一行代码的作用
- [ ] 能说出如果遍历`nums`会导致什么问题

### 复杂度层面
- [ ] 能证明为什么是O(n)而非O(n²)
- [ ] 能举例说明最坏情况下访问次数
- [ ] 能说出空间复杂度来源

### 推演层面
- [ ] 能不调试代码，手动推演示例 `[100,4,200,1,3,2]` 的执行过程
- [ ] 能说出 `[1,0,1,2]` 的执行路径
- [ ] 能解释 `[0,0,0]` 这种重复数据的处理

### 变种层面
- [ ] 如果要求返回序列本身而非长度，怎么改？
- [ ] 如果数组是有序的，最优解是什么？
- [ ] 如果要求O(1)空间，有什么思路？（困难）

---

## 🎯 面试现场 checklist

- [ ] 先问清返回值是长度还是序列
- [ ] 确认O(n)是时间还是空间要求
- [ ] 快速说出2种暴力方法展示思路
- [ ] 画出"起点判断"的逻辑
- [ ] 手写代码时先写Set和边界
- [ ] 写完主动分析复杂度

**掌握以上全部，这道题记在你DNA里了。**