# [73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

给定一个 `*m* x *n*` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法**。**



 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg)

```
输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg)

```
输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]
```

 

**提示：**

- `m == matrix.length`
- `n == matrix[0].length`
- `1 <= m, n <= 200`
- `-231 <= matrix[i][j] <= 231 - 1`

 

**进阶：**

- 一个直观的解决方案是使用  `O(*m**n*)` 的额外空间，但这并不是一个好的解决方案。
- 一个简单的改进方案是使用 `O(*m* + *n*)` 的额外空间，但这仍然不是最好的解决方案。
- 你能想出一个仅使用常量空间的解决方案吗？





## 题目分析与解题思路

这是一个经典的「矩阵置零」问题（LeetCode 73题）。关键点在于**原地算法**和**常量空间**的要求。

### 一、如何分析题目

**核心要求**：
- 发现0元素 → 将该元素所在行和列全部设为0
- 原地算法：直接修改输入矩阵，不返回新矩阵
- 空间复杂度：O(1)（常量额外空间）

**示例分析**：
```javascript
// 输入
[[1,1,1],
 [1,0,1],
 [1,1,1]]

// 输出：第2行和第2列全部置0
[[1,0,1],
 [0,0,0],
 [1,0,1]]
```

### 二、从暴力到最优的演进

#### 解法1：暴力法（O(mn)空间）
```javascript
var setZeroes = function(matrix) {
    const rows = matrix.length;
    const cols = matrix[0].length;
    const zeros = []; // 存储所有0的位置
    
    // 第一次遍历：记录所有0的坐标
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (matrix[i][j] === 0) {
                zeros.push([i, j]);
            }
        }
    }
    
    // 第二次遍历：根据记录的坐标置零
    for (const [i, j] of zeros) {
        // 置零第i行
        for (let k = 0; k < cols; k++) {
            matrix[i][k] = 0;
        }
        // 置零第j列
        for (let k = 0; k < rows; k++) {
            matrix[k][j] = 0;
        }
    }
};
```
**问题**：需要额外数组存储所有0的位置，空间复杂度O(mn)

---

#### 解法2：改进版（O(m+n)空间）
```javascript
var setZeroes = function(matrix) {
    const rows = matrix.length;
    const cols = matrix[0].length;
    const zeroRows = new Set(); // 需要置零的行
    const zeroCols = new Set(); // 需要置零的列
    
    // 第一次遍历：记录需要置零的行和列
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (matrix[i][j] === 0) {
                zeroRows.add(i);
                zeroCols.add(j);
            }
        }
    }
    
    // 第二次遍历：根据记录置零
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (zeroRows.has(i) || zeroCols.has(j)) {
                matrix[i][j] = 0;
            }
        }
    }
};
```
**问题**：需要两个Set存储行列信息，空间复杂度O(m+n)

---

### 三、最优算法（O(1)空间）

**核心思想**：用矩阵的第一行和第一列作为"标记位"，记录哪些行/列需要置零。

#### 算法步骤详解：

1. **预处理第一行和第一列**
   - 用两个变量 `firstRowHasZero` 和 `firstColHasZero` 记录第一行/列是否原本就有0
   - 因为第一行和第一列要被用作"标记位"，需要特殊处理

2. **使用第一行和第一列做标记**
   - 遍历矩阵（从第1行第1列开始）
   - 如果 `matrix[i][j] === 0`，就将 `matrix[i][0]` 和 `matrix[0][j]` 设为0
   - 这样，第一列的0表示第i行需要置零，第一行的0表示第j列需要置零

3. **根据标记置零矩阵**
   - 再次遍历矩阵（从第1行第1列开始）
   - 如果 `matrix[i][0] === 0` 或 `matrix[0][j] === 0`，就将 `matrix[i][j]` 设为0

4. **处理第一行和第一列**
   - 根据第一步记录的标记，决定是否将第一行和第一列置零

#### 完整实现：

```javascript
var setZeroes = function(matrix) {
    // ==================== 第1部分：初始化变量 ====================
    const rows = matrix.length;          // 矩阵行数
    const cols = matrix[0].length;       // 矩阵列数
    let firstRowHasZero = false;         // 标记第一行是否有0
    let firstColHasZero = false;         // 标记第一列是否有0
    
    // ==================== 第2部分：检查第一行和第一列 ====================
    // 检查第一行是否有0
    for (let j = 0; j < cols; j++) {
        if (matrix[0][j] === 0) {
            firstRowHasZero = true;
            break; // 找到即可跳出
        }
    }
    
    // 检查第一列是否有0
    for (let i = 0; i < rows; i++) {
        if (matrix[i][0] === 0) {
            firstColHasZero = true;
            break; // 找到即可跳出
        }
    }
    
    // ==================== 第3部分：使用第一行和第一列做标记 ====================
    // 从第1行第1列开始遍历（跳过第一行和第一列）
    for (let i = 1; i < rows; i++) {
        for (let j = 1; j < cols; j++) {
            // 如果当前元素是0
            if (matrix[i][j] === 0) {
                // 在对应的第一列和第一行做标记
                matrix[i][0] = 0;  // 第i行需要置零
                matrix[0][j] = 0;  // 第j列需要置零
            }
        }
    }
    
    // ==================== 第4部分：根据标记置零矩阵 ====================
    // 再次遍历（从第1行第1列开始）
    for (let i = 1; i < rows; i++) {
        for (let j = 1; j < cols; j++) {
            // 如果对应的第一列或第一行有标记
            if (matrix[i][0] === 0 || matrix[0][j] === 0) {
                matrix[i][j] = 0;  // 置零当前元素
            }
        }
    }
    
    // ==================== 第5部分：处理第一行和第一列 ====================
    // 如果第一行原本有0，则置零第一行
    if (firstRowHasZero) {
        for (let j = 0; j < cols; j++) {
            matrix[0][j] = 0;
        }
    }
    
    // 如果第一列原本有0，则置零第一列
    if (firstColHasZero) {
        for (let i = 0; i < rows; i++) {
            matrix[i][0] = 0;
        }
    }
    
    // 函数没有返回值，直接修改了输入的matrix
};
```

### 四、代码逐行解读

| 代码段                                            | 作用                                          |
| ------------------------------------------------- | --------------------------------------------- |
| `const rows = matrix.length`                      | 获取矩阵行数                                  |
| `let firstRowHasZero = false`                     | 布尔标记，记录第一行是否原本有0               |
| `for (let j = 0; j < cols; j++)`                  | 遍历第一行，检查是否有0                       |
| `for (let i = 1; i < rows; i++)`                  | **关键**：从第1行开始，跳过第一行             |
| `for (let j = 1; j < cols; j++)`                  | **关键**：从第1列开始，跳过第一列             |
| `if (matrix[i][j] === 0)`                         | 发现0元素                                     |
| `matrix[i][0] = 0`                                | **标记**：在第i行开头做标记，表示该行需要置零 |
| `matrix[0][j] = 0`                                | **标记**：在第j列顶部做标记，表示该列需要置零 |
| `if (matrix[i][0] === 0 \|\| matrix[0][j] === 0)` | 根据标记判断是否置零                          |
| `if (firstRowHasZero)`                            | 最后处理第一行，避免标记被覆盖                |

### 五、面试手搓算法技巧

 **面试时建议的编写顺序**  ：

1. **先写框架**：
```javascript
var setZeroes = function(matrix) {
    const rows = matrix.length;
    const cols = matrix[0].length;
    let firstRowHasZero = false;
    let firstColHasZero = false;
    
    // ...后续填充
};
```

2. **写检查第一行/列的逻辑**（简单，建立信心）
3. **写标记逻辑**（核心，先写外层循环，再填充内层）
4. **写置零逻辑**（根据标记处理）
5. **最后处理第一行/列**（收尾工作）

**关键注释**：面试时务必边写边解释，特别是为什么跳过第一行/列、标记的原理等。

**时间复杂度**：O(m×n) - 遍历矩阵4次，但每个元素访问次数是常数
**空间复杂度**：O(1) - 只用了两个布尔变量和循环变量





## 一、基础语法解释

### 1. 为什么`matrix.length`是行数？

`matrix`是一个**二维数组**（数组的数组），结构如下：

```javascript
matrix = [
  [1, 2, 3],  // ← matrix[0]，第0行
  [4, 5, 6],  // ← matrix[1]，第1行
  [7, 8, 9]   // ← matrix[2]，第2行
]
```

- `matrix.length`：获取**外层数组**的元素个数 → **行数**（3行）
- `matrix[0]`：获取**第一行**（内层数组）→ `[1, 2, 3]`
- `matrix[0].length`：获取**第一行的长度** → **列数**（3列）

### 2. "Do not return anything, modify matrix in-place instead."

这句话的意思是：
- **不要返回任何值**：函数执行完不需要 `return` 结果
- **原地修改**：直接修改传入的 `matrix` 参数本身，而不是创建新矩阵

```javascript
// ❌ 错误示范：返回新矩阵
function setZeroes(matrix) {
  const newMatrix = ...; // 创建新矩阵
  return newMatrix;      // 返回新矩阵
}

// ✅ 正确示范：原地修改
function setZeroes(matrix) {
  // 直接修改 matrix[i][j] = 0
  // 不需要 return
}
```

---

## 二、最优算法 - 无注释版本

```javascript
var setZeroes = function(matrix) {
    const rows = matrix.length;
    const cols = matrix[0].length;
    let firstRowHasZero = false;
    let firstColHasZero = false;
    
    for (let j = 0; j < cols; j++) {
        if (matrix[0][j] === 0) {
            firstRowHasZero = true;
            break;
        }
    }
    
    for (let i = 0; i < rows; i++) {
        if (matrix[i][0] === 0) {
            firstColHasZero = true;
            break;
        }
    }
    
    for (let i = 1; i < rows; i++) {
        for (let j = 1; j < cols; j++) {
            if (matrix[i][j] === 0) {
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }
    
    for (let i = 1; i < rows; i++) {
        for (let j = 1; j < cols; j++) {
            if (matrix[i][0] === 0 || matrix[0][j] === 0) {
                matrix[i][j] = 0;
            }
        }
    }
    
    if (firstRowHasZero) {
        for (let j = 0; j < cols; j++) {
            matrix[0][j] = 0;
        }
    }
    
    if (firstColHasZero) {
        for (let i = 0; i < rows; i++) {
            matrix[i][0] = 0;
        }
    }
};
```

---

## 三、最优算法 - 逐行注释版本

```javascript
var setZeroes = function(matrix) {
    const rows = matrix.length;          // 获取矩阵行数
    const cols = matrix[0].length;       // 获取矩阵列数
    let firstRowHasZero = false;         // 标记：第一行是否有0
    let firstColHasZero = false;         // 标记：第一列是否有0
    
    // 检查第一行是否有0
    for (let j = 0; j < cols; j++) {
        if (matrix[0][j] === 0) {
            firstRowHasZero = true;      // 发现0，标记为true
            break;                       // 找到即可跳出循环
        }
    }
    
    // 检查第一列是否有0
    for (let i = 0; i < rows; i++) {
        if (matrix[i][0] === 0) {
            firstColHasZero = true;      // 发现0，标记为true
            break;                       // 找到即可跳出循环
        }
    }
    
    // 遍历矩阵（跳过第一行和第一列）
    for (let i = 1; i < rows; i++) {
        for (let j = 1; j < cols; j++) {
            if (matrix[i][j] === 0) {    // 如果当前元素是0
                matrix[i][0] = 0;        // 在对应第一列做标记（表示第i行要置零）
                matrix[0][j] = 0;        // 在对应第一行做标记（表示第j列要置零）
            }
        }
    }
    
    // 再次遍历矩阵（跳过第一行和第一列）
    for (let i = 1; i < rows; i++) {
        for (let j = 1; j < cols; j++) {
            if (matrix[i][0] === 0 || matrix[0][j] === 0) {
                matrix[i][j] = 0;        // 根据标记置零当前元素
            }
        }
    }
    
    // 处理第一行：如果原本有0，则置零整行
    if (firstRowHasZero) {
        for (let j = 0; j < cols; j++) {
            matrix[0][j] = 0;            // 将第一行所有元素设为0
        }
    }
    
    // 处理第一列：如果原本有0，则置零整列
    if (firstColHasZero) {
        for (let i = 0; i < rows; i++) {
            matrix[i][0] = 0;            // 将第一列所有元素设为0
        }
    }
};
```

---

## 四、最优算法 - 逐行解读版本

### 初始化阶段
```javascript
const rows = matrix.length;      // 行数 = 外层数组长度
const cols = matrix[0].length;   // 列数 = 第一行数组长度
let firstRowHasZero = false;     // 记录第一行原本是否有0
let firstColHasZero = false;     // 记录第一列原本是否有0
```
**目的**：获取矩阵尺寸，并准备两个标记变量记录第一行/列的原始状态。

---

### 步骤1：检查第一行和第一列
```javascript
// 检查第一行
for (let j = 0; j < cols; j++) {
    if (matrix[0][j] === 0) {
        firstRowHasZero = true;  // 发现0，做标记
        break;                   // 提前退出，提高效率
    }
}

// 检查第一列
for (let i = 0; i < rows; i++) {
    if (matrix[i][0] === 0) {
        firstColHasZero = true;  // 发现0，做标记
        break;
    }
}
```
**目的**：因为后续要用第一行/列做"标记位"，必须提前知道它们原本是否有0，否则这些信息会丢失。

---

### 步骤2：使用第一行和第一列做标记（核心）
```javascript
for (let i = 1; i < rows; i++) {     // i从1开始，跳过第一行
    for (let j = 1; j < cols; j++) { // j从1开始，跳过第一列
        if (matrix[i][j] === 0) {    // 发现0元素
            matrix[i][0] = 0;        // 在第i行开头标记：此行要置零
            matrix[0][j] = 0;        // 在第j列顶部标记：此列要置零
        }
    }
}
```
**原理**：遍历矩阵内部区域（绿色部分），用第一行和第一列作为"公告板"：
- **第一列的0**：表示对应行需要置零
- **第一行的0**：表示对应列需要置零

**示例**：
```
原始矩阵：        标记后：
[1 1 1 1]        [1 1 1 1]
[1 0 1 1]   →    [0 1 0 1]  ← 第2行第0列标记0
[1 1 1 1]        [1 1 1 1]
[1 1 0 1]        [1 0 1 1]  ← 第4行第0列标记0
```
（非第一行/列的0会让对应的第一行/列位置标记为0）

---

### 步骤3：根据标记置零矩阵
```javascript
for (let i = 1; i < rows; i++) {     // i从1开始，跳过第一行
    for (let j = 1; j < cols; j++) { // j从1开始，跳过第一列
        if (matrix[i][0] === 0 || matrix[0][j] === 0) {
            matrix[i][j] = 0;        // 该行或该列有标记，则置零
        }
    }
}
```
**原理**：再次遍历内部区域，查看"公告板"：
- 如果 `matrix[i][0] === 0` → 第i行需要置零
- 如果 `matrix[0][j] === 0` → 第j列需要置零
- 满足任一条件，当前元素就置零

---

### 步骤4：处理第一行和第一列
```javascript
// 根据原始标记，决定是否置零第一行
if (firstRowHasZero) {
    for (let j = 0; j < cols; j++) {
        matrix[0][j] = 0;            // 置零第一行所有元素
    }
}

// 根据原始标记，决定是否置零第一列
if (firstColHasZero) {
    for (let i = 0; i < rows; i++) {
        matrix[i][0] = 0;            // 置零第一列所有元素
    }
}
```
**原理**：最后处理第一行/列，因为它们被用作标记位，现在根据步骤1记录的原始状态进行最终处理。

---

### 完整流程总结

| 步骤 | 操作          | 遍历范围                  | 目的                          |
| ---- | ------------- | ------------------------- | ----------------------------- |
| 1    | 检查第一行/列 | 第一行、第一列            | 记录原始状态                  |
| 2    | 做标记        | 内部区域（跳过第一行/列） | 用第一行/列记录哪些行列需置零 |
| 3    | 置零          | 内部区域（跳过第一行/列） | 根据标记置零                  |
| 4    | 处理第一行/列 | 第一行、第一列            | 根据原始状态置零              |

**空间复杂度**：只用了2个布尔变量 → **O(1)**  
**时间复杂度**：遍历矩阵4次 → **O(m×n)**

这样就实现了原地修改矩阵，且不使用额外空间！
