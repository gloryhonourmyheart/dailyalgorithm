# 56.合并区间

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

 

示例 1：

输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
示例 2：

输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
示例 3：

输入：intervals = [[4,7],[1,4]]
输出：[[1,7]]
解释：区间 [1,4] 和 [4,7] 可被视为重叠区间。


提示：

1 <= intervals.length <= 104
intervals[i].length == 2
0 <= starti <= endi <= 104



## 解题思路

这是一个经典的区间合并问题。标准解法是：

1. **排序**：首先按区间的起始位置对所有区间进行排序
2. **遍历合并**：然后遍历排序后的区间，逐个检查是否需要合并
3. **合并条件**：如果当前区间的起始位置 ≤ 上一个区间的结束位置，说明重叠，可以合并
4. **更新区间**：合并时，新区间的结束位置取两者最大值

## 代码实现

```javascript
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function(intervals) {
    if (intervals.length <= 1) {
        return intervals;
    }
    
    // 1. 按区间的起始位置排序
    intervals.sort((a, b) => a[0] - b[0]);
    
    const result = [];
    // 2. 初始化第一个区间为当前区间
    let current = intervals[0];
    
    // 3. 遍历所有区间
    for (let i = 1; i < intervals.length; i++) {
        const next = intervals[i];
        
        // 4. 检查是否重叠：如果 next.start <= current.end，说明重叠
        if (next[0] <= current[1]) {
            // 5. 合并区间：更新 current.end 为最大值
            current[1] = Math.max(current[1], next[1]);
        } else {
            // 6. 不重叠，将 current 加入结果
            result.push(current);
            // 7. 更新 current 为新的区间
            current = next;
        }
    }
    
    // 8. 将最后一个区间加入结果
    result.push(current);
    
    return result;
};
```

## 详细解释

以示例 `intervals = [[1,3],[2,6],[8,10],[15,18]]` 为例：

1. **排序后**：`[[1,3],[2,6],[8,10],[15,18]]` （已经是排序好的）
2. **初始化**：`current = [1,3]`
3. **遍历过程**：
   - i=1: `next = [2,6]`, 2 ≤ 3 重叠 → 合并为 `[1,6]` (current = [1,6])
   - i=2: `next = [8,10]`, 8 > 6 不重叠 → 将 `[1,6]` 加入结果，current = [8,10]
   - i=3: `next = [15,18]`, 15 > 10 不重叠 → 将 `[8,10]` 加入结果，current = [15,18]
4. **最后**：将 `[15,18]` 加入结果
5. **最终结果**：`[[1,6],[8,10],[15,18]]`

## 复杂度分析

- **时间复杂度**：**O(n log n)**，其中 n 是区间数量。主要是排序的耗时。
- **空间复杂度**：**O(log n)** 到 **O(n)**，取决于排序算法的实现（快速排序为 O(log n)，归并排序为 O(n)）。

## 测试用例

```javascript
// 测试用例 1
console.log(merge([[1,3],[2,6],[8,10],[15,18]]));
// 输出: [[1,6],[8,10],[15,18]]

// 测试用例 2
console.log(merge([[1,4],[4,5]]));
// 输出: [[1,5]]

// 测试用例 3
console.log(merge([[4,7],[1,4]]));
// 输出: [[1,7]]

// 测试用例 4：无重叠
console.log(merge([[1,2],[3,4],[5,6]]));
// 输出: [[1,2],[3,4],[5,6]]

// 测试用例 5：全部被合并
console.log(merge([[1,4],[2,3],[3,5]]));
// 输出: [[1,5]]
```

这个解法是合并区间问题的最优解，既简洁又高效！