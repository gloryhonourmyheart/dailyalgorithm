**283. 移动零（Move Zeroes）——从暴力到最优的完整思路**  

下面给出**从拿到题目到写出最优解**的全过程，包括：

1. **题目分析**——我们要完成什么、关键约束是什么  
2. **暴力思路**——最直观的“把0往后挪”方法  
3. **下意识的改进（双指针交换版）**——一次遍历把非零数往前交换  
4. **最优解法（双指针两次遍历）**——最小化写入次数的原地算法  
5. **完整代码**（JavaScript）并**逐行注释**  
6. **复杂度对比**与**常见陷阱**  

所有代码都直接覆盖题目给出的模板 `var moveZeroes = function(nums) { … }`，不改动函数签名，符合“原地操作、不返回任何值”的要求。

---

## 1. 题目分析

- **输入**：一个整数数组 `nums`（长度 1 ~ 10⁴，元素在 32 位整数范围）  
- **输出**：把数组中所有 `0` 移动到数组**末尾**，非零元素的**相对顺序**保持不变。  
- **关键约束**：**必须原地修改**，不能新建数组或复制数据。  
- **进阶**：**最小化完成的操作次数**（主要指对数组的写入/交换次数）。

> 例如  
> `nums = [0,1,0,3,12]` → `[1,3,12,0,0]`  
> `nums = [0]` → `[0]`

把问题抽象一下，就是一次**稳定划分**（stable partition）：把所有非零元素放到左侧，零放在右侧，且非零的顺序不能变。

---

## 2. 暴力思路（O(n²)）

最直观的想法：**遍历数组，每遇到一个 0，就把它后面的所有元素左移一位，然后在末尾补一个 0**。  

伪代码如下：

```javascript
function moveZeroesBrute(nums) {
    let n = nums.length;
    for (let i = 0; i < n; i++) {
        if (nums[i] === 0) {          // 找到一个 0
            // 把 i 之后的所有元素左移一位
            for (let j = i + 1; j < n; j++) {
                nums[j - 1] = nums[j];
            }
            nums[n - 1] = 0;            // 末尾补 0
            // 注意：这次左移后，i 位置已经被原来的 i+1 占据，
            // 需要再次检查 i（所以 i--），否则可能漏掉连续 0
            i--;                        // 重新检查当前位置
        }
    }
}
```

**为什么慢？**  
每一次遇到 0，都可能导致 `O(n)` 次左移。最坏情况（全是 0 或全是非零）时间复杂度是 `O(n²)`，且写入次数极多。显然不符合“进阶”要求。

---

## 3. 下意识的改进：双指针（交换版）O(n)

我们不想把每个 0 都“往后推”，而是**把非零数往前搬**。只要维护两个指针：

- `left`：下一个非零元素应该放置的位置（左侧已经处理好的区间终点）
- `right`：遍历指针，扫描整个数组

思路：

1. `right` 从 `0` 到 `n‑1` 遍历。  
2. 当 `nums[right] !== 0` 时，说明找到一个非零元素。  
3. 把它和 `nums[left]` 交换（如果 `left !== right`），然后 `left++`。  

这样一次遍历就把所有非零元素“压”到左侧，零自然被挤到右侧。

```javascript
var moveZeroesSwap = function(nums) {
    let left = 0;                     // left 指向下一个可以放非零元素的位置
    for (let right = 0; right < nums.length; right++) {
        if (nums[right] !== 0) {      // 找到一个非零元素
            // 交换 left 和 right 位置
            let tmp = nums[left];
            nums[left] = nums[right];
            nums[right] = tmp;
            left++;                   // left 向前移动，已经放好一个非零
        }
    }
};
```

**优点**：只遍历一次，时间 `O(n)`，额外空间 `O(1)`。  
**缺点**：每次都要做一次交换（三次赋值），如果 `left === right`（本来就是非零且在正确位置），这次交换是多余的。

---

## 4. 最优解法：双指针（两次遍历）O(n) **最少写入**

我们希望在**保持顺序的前提下，尽量减少对数组的写入次数**。观察上面的交换解法，实际上只有非零元素需要**一次写入**到左侧，后面的 0 可以在最后再统一填充。

**思路**（两次遍历）：

1. **第一次遍历**：把所有非零元素按顺序移到数组前面，用一个指针 `insertPos` 记录下一个可以插入的位置。  
   - 遇到非零 `nums[i]` → `nums[insertPos] = nums[i]`，然后 `insertPos++`。  
2. **第二次遍历**：把 `insertPos` 到数组末尾的所有位置全部填 `0`。

这样每个非零元素只被写入一次，每个 0 也只被写入一次（全部集中在第二次遍历），整体写入次数 `≈ n`（理论最小）。

代码（JavaScript）：

```javascript
/**
 * 将所有 0 移动到数组末尾，保持非零元素相对顺序
 * @param {number[]} nums - 待修改的数组（原地）
 * @return {void} 不返回任何值，直接修改 nums
 */
var moveZeroes = function(nums) {
    // --------------- 第一次遍历：收集所有非零元素 ---------------
    let insertPos = 0;                     // insertPos 指向下一个可以放置非零元素的位置
    for (let i = 0; i < nums.length; i++) {   // i 为遍历指针
        if (nums[i] !== 0) {               // 只处理非零元素
            nums[insertPos] = nums[i];     // 把非零元素放到 insertPos 位置
            insertPos++;                   // insertPos 向后移动，准备接收下一个非零
        }
    }
    // 此时 [0, insertPos) 区间里已经是所有非零元素，且保持原有顺序

    // --------------- 第二次遍历：把剩余位置全部填 0 ---------------
    for (let i = insertPos; i < nums.length; i++) {
        nums[i] = 0;                       // 直接用 0 填充剩余区间
    }
};
```

**为什么它最优？**  
- 时间复杂度仍然是 `O(n)`（两次线性遍历）。  
- 写入次数：每个非零元素恰好写入一次，剩下的 `n‑insertPos` 个位置第二次遍历全部置 0，整体写入次数 `n`（最小可能）。  
- 不需要多余的交换或判断 `left === right`，代码更简洁、常数因子更小。

---

## 5. 代码逐行注释（完整版）

把上面的“最优解法”直接嵌入题目模板，并加上更详细的行内注释：

```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
    // 1. 第一次遍历：将所有非零元素按顺序移到数组前面
    let insertPos = 0;                     // insertPos 指向下一个可以放置非零元素的位置
    for (let i = 0; i < nums.length; i++) {   // i 为从头到尾的遍历指针
        if (nums[i] !== 0) {               // 只关心非零元素，零直接跳过
            nums[insertPos] = nums[i];     // 把当前非零元素搬到 insertPos 位置
            insertPos++;                   // insertPos 向后移动，为下一个非零元素准备空位
        }
    }
    // 循环结束后，[0, insertPos) 区间已经存放所有非零元素，且相对顺序不变
    // 剩下的 [insertPos, nums.length) 区间就需要全部填成 0

    // 2. 第二次遍历：把剩余的位置全部填 0
    for (let i = insertPos; i < nums.length; i++) {
        nums[i] = 0;                       // 直接将当前位置赋值为 0
    }
    // 完成后，所有 0 都被移到了数组末尾，非零顺序保持不变
};
```

**关键点回顾**（对应注释）：

- `insertPos` 既是“下一个可写位置”，也是已经处理好的非零元素的个数。  
- 第一次遍历 **不写 0**，只把非零往左搬。  
- 第二次遍历 **不写非零**，只把剩余部位填 0。  
- 两次遍历加起来正好把数组每个位置都写入一次（或零次），实现最小化写入。

---

## 6. 复杂度对比与常见陷阱

| 方案         | 时间复杂度 | 额外空间   | 写入/交换次数 (约)                            | 说明                         |
| ------------ | ---------- | ---------- | --------------------------------------------- | ---------------------------- |
| 暴力左移     | `O(n²)`    | `O(1)`     | 最多 `n²` 次写入                              | 实现简单，但超时风险         |
| 双指针交换   | `O(n)`     | `O(1)`     | 约 `2·(非零个数)` 次写入（每次交换 3 次赋值） | 常用、易于理解，但有冗余交换 |
| **两次遍历** | **`O(n)`** | **`O(1)`** | **`n` 次写入**（每个元素恰好一次）            | **最优**，满足“最小操作”要求 |

**常见陷阱**：

1. **忽略 `i !== left` 判断** → 交换版会把同一位置的元素自己跟自己交换，虽然没错但多余。  
2. **忘记第二次填 0** →  resulting 数组末尾可能残留旧数据。  
3. **试图使用 `splice` 或新建数组** → 违反“原地操作”约束。  
4. **在 `for` 循环里删除/插入元素** → 会导致索引错位、漏检元素。

---

## 7. 小结

- **拿到题目**：先想清楚“原地稳定划分”是关键，避免新建数组。  
- **暴力思路**：把每个 0 往后推，时间 `O(n²)`，仅用于理解问题。  
- **下意识改进**：双指针交换版，一次遍历完成划分，时间 `O(n)`，但有冗余交换。  
- **最优方案**：两次遍历——先把非零搬到前面，再统一填 0，写入次数最少，时间 `O(n)`、空间 `O(1)`。  
- **实现细节**：注意 `insertPos` 指针的作用、循环结束后填充 0 的范围。  

以上即为 **283. 移动零** 从分析到最优解的完整过程，配合逐行注释的代码可以直接复制到 LeetCode 或其他 OJ 平台运行。祝你编码愉快 🚀!