# [283. 移动零](https://leetcode.cn/problems/move-zeroes/)





提示



给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

 

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

 

**提示**:

- `1 <= nums.length <= 104`
- `-231 <= nums[i] <= 231 - 1`

 

**进阶：**你能尽量减少完成的操作次数吗？





# 283. 移动零 - 面试手搓版

## 一、题目要点（面试时先默念一遍）

```
输入: nums = [0,1,0,3,12]  
输出: [1,3,12,0,0]

约束：
❌ 不能新建数组
✅ 只能原地修改 nums
✅ 保持非零元素相对顺序
🎯 进阶：最小化操作次数
```

---

## 二、代码框架（手写起点）

```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
    // 第一次遍历：收集所有非零元素
    
    
    // 第二次遍历：填充剩余位置为0
    
    
};
```

---

## 三、无注释完整代码（你的目标）

```javascript
var moveZeroes = function(nums) {
    let insertPos = 0;
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== 0) {
            nums[insertPos] = nums[i];
            insertPos++;
        }
    }
    for (let i = insertPos; i < nums.length; i++) {
        nums[i] = 0;
    }
};
```



## 2. 下意识的改进：双指针（交换版）O(n)

我们不想把每个 0 都“往后推”，而是**把非零数往前搬**。只要维护两个指针：

- `left`：下一个非零元素应该放置的位置（左侧已经处理好的区间终点）
- `right`：遍历指针，扫描整个数组

思路：

1. `right` 从 `0` 到 `n‑1` 遍历。
2. 当 `nums[right] !== 0` 时，说明找到一个非零元素。
3. 把它和 `nums[left]` 交换（如果 `left !== right`），然后 `left++`。

这样一次遍历就把所有非零元素“压”到左侧，零自然被挤到右侧。

JavaScript

复制

```javascript
var moveZeroesSwap = function(nums) {
    let left = 0;                     // left 指向下一个可以放非零元素的位置
    for (let right = 0; right < nums.length; right++) {
        if (nums[right] !== 0) {      // 找到一个非零元素
            // 交换 left 和 right 位置
            let tmp = nums[left];
            nums[left] = nums[right];
            nums[right] = tmp;
            left++;                   // left 向前移动，已经放好一个非零
        }
    }
};
```

**优点**：只遍历一次，时间 `O(n)`，额外空间 `O(1)`。
**缺点**：每次都要做一次交换（三次赋值），如果 `left === right`（本来就是非零且在正确位置），这次交换是多余的。

------

## 3. 最优解法：双指针（两次遍历）O(n) **最少写入**

我们希望在**保持顺序的前提下，尽量减少对数组的写入次数**。观察上面的交换解法，实际上只有非零元素需要**一次写入**到左侧，后面的 0 可以在最后再统一填充。

**思路**（两次遍历）：

1. **第一次遍历**：把所有非零元素按顺序移到数组前面，用一个指针 `insertPos` 记录下一个可以插入的位置。
   - 遇到非零 `nums[i]` → `nums[insertPos] = nums[i]`，然后 `insertPos++`。
2. **第二次遍历**：把 `insertPos` 到数组末尾的所有位置全部填 `0`。

这样每个非零元素只被写入一次，每个 0 也只被写入一次（全部集中在第二次遍历），整体写入次数 `≈ n`（理论最小）。

代码（JavaScript）：

JavaScript

复制

```javascript
/**
 * 将所有 0 移动到数组末尾，保持非零元素相对顺序
 * @param {number[]} nums - 待修改的数组（原地）
 * @return {void} 不返回任何值，直接修改 nums
 */
var moveZeroes = function(nums) {
    // --------------- 第一次遍历：收集所有非零元素 ---------------
    let insertPos = 0;                     // insertPos 指向下一个可以放置非零元素的位置
    for (let i = 0; i < nums.length; i++) {   // i 为遍历指针
        if (nums[i] !== 0) {               // 只处理非零元素
            nums[insertPos] = nums[i];     // 把非零元素放到 insertPos 位置
            insertPos++;                   // insertPos 向后移动，准备接收下一个非零
        }
    }
    // 此时 [0, insertPos) 区间里已经是所有非零元素，且保持原有顺序

    // --------------- 第二次遍历：把剩余位置全部填 0 ---------------
    for (let i = insertPos; i < nums.length; i++) {
        nums[i] = 0;                       // 直接用 0 填充剩余区间
    }
};
```

**为什么它最优？**

- 时间复杂度仍然是 `O(n)`（两次线性遍历）。
- 写入次数：每个非零元素恰好写入一次，剩下的 `n‑insertPos` 个位置第二次遍历全部置 0，整体写入次数 `n`（最小可能）。
- 不需要多余的交换或判断 `left === right`，代码更简洁、常数因子更小。

------

## 4. 代码逐行注释（完整版）

把上面的“最优解法”直接嵌入题目模板，并加上更详细的行内注释：

JavaScript

复制

```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
    // 1. 第一次遍历：将所有非零元素按顺序移到数组前面
    let insertPos = 0;                     // insertPos 指向下一个可以放置非零元素的位置
    for (let i = 0; i < nums.length; i++) {   // i 为从头到尾的遍历指针
        if (nums[i] !== 0) {               // 只关心非零元素，零直接跳过
            nums[insertPos] = nums[i];     // 把当前非零元素搬到 insertPos 位置
            insertPos++;                   // insertPos 向后移动，为下一个非零元素准备空位
        }
    }
    // 循环结束后，[0, insertPos) 区间已经存放所有非零元素，且相对顺序不变
    // 剩下的 [insertPos, nums.length) 区间就需要全部填成 0

    // 2. 第二次遍历：把剩余的位置全部填 0
    for (let i = insertPos; i < nums.length; i++) {
        nums[i] = 0;                       // 直接将当前位置赋值为 0
    }
    // 完成后，所有 0 都被移到了数组末尾，非零顺序保持不变
};
```

**关键点回顾**（对应注释）：

- `insertPos` 既是“下一个可写位置”，也是已经处理好的非零元素的个数。
- 第一次遍历 **不写 0**，只把非零往左搬。
- 第二次遍历 **不写非零**，只把剩余部位填 0。
- 两次遍历加起来正好把数组每个位置都写入一次（或零次），实现最小化写入。

------

## 5. 复杂度对比与常见陷阱

表格

复制

| 方案         | 时间复杂度 | 额外空间   | 写入/交换次数 (约)                            | 说明                         |
| :----------- | :--------- | :--------- | :-------------------------------------------- | :--------------------------- |
| 暴力左移     | `O(n²)`    | `O(1)`     | 最多 `n²` 次写入                              | 实现简单，但超时风险         |
| 双指针交换   | `O(n)`     | `O(1)`     | 约 `2·(非零个数)` 次写入（每次交换 3 次赋值） | 常用、易于理解，但有冗余交换 |
| **两次遍历** | **`O(n)`** | **`O(1)`** | **`n` 次写入**（每个元素恰好一次）            | **最优**，满足“最小操作”要求 |

**常见陷阱**：

1. **忽略 `i !== left` 判断** → 交换版会把同一位置的元素自己跟自己交换，虽然没错但多余。
2. **忘记第二次填 0** →  resulting 数组末尾可能残留旧数据。
3. **试图使用 `splice` 或新建数组** → 违反“原地操作”约束。
4. **在 `for` 循环里删除/插入元素** → 会导致索引错位、漏检元素。

---

## 四、手搓自查清单（写完后逐条打勾）

### 变量部分
- [ ] 声明了 `insertPos` 指针，初始化为 **0**
- [ ] 声明了遍历指针 `i`，从 **0** 到 `nums.length - 1`

### 第一次遍历
- [ ] 循环条件写成 `i < nums.length`（不是 `<=`）
- [ ] 判断 `nums[i] !== 0`（严格不等于）
- [ ] 赋值语句 `nums[insertPos] = nums[i]`（顺序不能反）
- [ ] `insertPos` 在赋值后**立即自增**
- [ ] **没有**在循环里写任何 `= 0` 的操作

### 第二次遍历
- [ ] 循环起点是 `insertPos`（不是 0）
- [ ] 循环终点是 `i < nums.length`
- [ ] 赋值语句 `nums[i] = 0`（简单直接）

### 边界检查
- [ ] 空数组 `[]` 不会报错
- [ ] 全零数组 `[0,0,0]` 能正确处理
- [ ] 无零数组 `[1,2,3]` 能正确处理
- [ ] 单个元素 `[0]` 或 `[1]` 能正确处理

---

## 五、高频错误预警（面试官最爱问）

| 错误类型                    | 错误代码                          | 后果             | 面试官反应    |
| --------------------------- | --------------------------------- | ---------------- | ------------- |
| **新建数组**                | `let arr = [];`                   | 空间复杂度 O(n)  | ❌ 直接挂      |
| **使用 filter**             | `nums.filter(...)`                | 违规复制         | ❌ 基础不牢    |
| ** splice 删除 **           | `nums.splice(i,1); nums.push(0);` | 内部复制 + O(n²) | ⚠️ 性能差      |
| ** 忘记填0 **               | 漏掉第二个循环                    | 末尾残留旧值     | ❌ 逻辑不完整  |
| ** insertPos 自增位置错误** | `nums[++insertPos] = nums[i];`    | 跳过第0个位置    | ❌ 越界/丢数据 |
| **用 while 忽略 i**         | `while(nums[i]===0) i++;`         | 逻辑复杂易错     | ⚠️ 不够优雅    |

---

## 六、复杂度速判（面试必问）

**时间复杂度：O(n)**
```javascript
// 心算方法：每个元素被访问几次？
// 第1个循环：每个元素1次 → n
// 第2个循环：剩(n-insertPos)个元素 → ≤ n
// 总计 ≤ 2n → 忽略常数 → O(n)
```

**空间复杂度：O(1)**
```javascript
// 心算方法：数 new 关键字
// 只用了 insertPos, i 两个变量 → 没有 new 数组/对象
// 占用空间不随 n 变化 → O(1)
```

---

## 七、算法对比（证明你懂最优）

| 方案                 | 代码行数 | 写入次数 | 空间     | 面试推荐指数 |
| -------------------- | -------- | -------- | -------- | ------------ |
| **暴力左移**         | ~10行    | ~n²/2    | O(1)     | ❌ 太慢       |
| **双指针交换**       | ~8行     | ~2n      | O(1)     | ⚠️ 有冗余     |
| **两次遍历（最优）** | **6行**  | **n**    | **O(1)** | ✅ **必背**   |

---

## 八、模拟面试场景

**面试官**：写一个函数把0移到最后，原地操作。

**你**：*（花10秒审题，默念约束）*  
**你**：*（在纸上写下框架）*
```javascript
var moveZeroes = function(nums) {
    let insertPos = 0;
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== 0) {
            nums[insertPos++] = nums[i];
        }
    }
    for (let i = insertPos; i < nums.length; i++) {
        nums[i] = 0;
    }
};
```
**你**：*（写完后对照清单逐条打勾，确认没犯低级错误）*

**面试官**：时间空间复杂度？
**你**：O(n) 时间，O(1) 额外空间，因为每个元素只访问两次，只用了两个指针变量。

**面试官**：为什么第二个循环从 insertPos 开始？
**你**：因为第一次遍历后，`[0, insertPos)` 已经是所有非零元素，`insertPos` 正好是第一个该填0的位置。

---

## 九、终极记忆口诀

```
审题看约束，原地是核心。
两个指针跑，非零往前靠。
insertPos 要自增，二次填0别忘掉。
空间 O(1) 时间 O(n)，面试稳了笑哈哈。
```

---

## 十、最后检查（离开白板前必问）

- [ ] **我有没有用 `new` 或 `[]`？** → 用了就错
- [ ] **我有没有修改数组长度？** → 修改了就错
- [ ] **我写了几个循环？** → 应该是2个
- [ ] **代码能处理空数组吗？** → 测试 `[]`
- [ ] **代码能处理全零吗？** → 测试 `[0,0,0]`

---

**现在，盖住答案，在白纸上默写三遍。如果你能在5分钟内无错误写出并讲清思路，恭喜你，面试稳了！**