###  对原型链的理解

我先把这段内容拆分解读，再帮你准备面试回答。别怕，原型链其实就像"家族遗传"——每个对象都有个"祖宗"，找不到的东西就问问祖宗，祖宗还找不到就问祖宗的祖宗……

---

## **一、逐句拆解：从零开始理解**

### **1. "每个对象都有一个内部的[[Prototype]]属性"**
```javascript
// 想象每个对象出生时就自带一个"血缘标签"
let 小明 = {
    名字: '小明',
    年龄: 18
};

// [[Prototype]]是隐藏属性，浏览器一般显示为__proto__
console.log(小明.__proto__); // 指向Object.prototype
```

**比喻**：每个对象就像一个"孩子"，生下来就带着一张"家谱卡"（`__proto__`），上面写着"我爸是谁"。

---

### **2. "访问属性时，先在自己身上找，找不到沿原型链向上"**
```javascript
let 父亲 = {
    姓氏: '张',
    会说: function() { return '我会讲普通话'; }
};

let 儿子 = {
    名字: '张三',
    爱好: '打篮球'
};

// 建立血缘关系：儿子的"爸"是父亲
儿子.__proto__ = 父亲; 

// 现在访问属性：
console.log(儿子.名字); // "张三" —— 自己身上就有，直接返回
console.log(儿子.姓氏); // "张" —— 自己身上没有，去问爸爸
console.log(儿子.会说()); // "我会讲普通话" —— 方法也是属性，同样继承

// 如果整个链条都找不到：
console.log(儿子.学历); // undefined —— 一直找到"祖宗"Object.prototype都没有
```

**动图想象**：`儿子.学历` → 儿子身上没有 → 沿着`__proto__`箭头到父亲 → 父亲也没有 → 再到父亲的父亲 → … → 到Object.prototype → null → 返回undefined

---

### **3. "Object.prototype是所有对象的祖先"**
```javascript
// 所有对象的"祖宗的老祖宗"
console.log(Object.prototype); 
// 上面有toString、hasOwnProperty等通用方法

// 验证：
let obj = {};
console.log(obj.__proto__ === Object.prototype); // true

let arr = [];
console.log(arr.__proto__ === Array.prototype); // true
console.log(arr.__proto__.__proto__ === Object.prototype); // true
// 数组 → Array.prototype → Object.prototype → null
```

**家族树**：
```
null
  ↑
Object.prototype (祖宗的老祖宗)
  ↑
Array.prototype (数组的爸爸)
  ↑
[] (数组实例)
```

---

### **4. "实现继承、共享属性、节省内存"**
```javascript
// ❌ 错误示范：每个对象都存一份方法，浪费内存
function 创建人(name) {
    return {
        name: name,
        说话: function() { return '你好'; } // 每个对象独立一份
    };
}
let p1 = 创建人('A');
let p2 = 创建人('B');
console.log(p1.说话 === p2.说话); // false —— 两份不同的函数

// ✅ 正确示范：把方法放到原型上共享
function 人(name) {
    this.name = name;
}
人.prototype.说话 = function() { return '你好'; }; // 只在原型存一份

let p3 = new 人('A');
let p4 = new 人('B');
console.log(p3.说话 === p4.说话); // true —— 同一个函数
p3.说话(); // "你好" —— p3自己没有，去原型上找
```

**核心**：原型上的东西只有一份，所有实例共享，像"家族共有财产"。

---

### **5. "修改原型会影响所有后代"**
```javascript
function Dog() {}
Dog.prototype.叫声 = '汪汪';

let 狗1 = new Dog();
let 狗2 = new Dog();
console.log(狗1.叫声, 狗2.叫声); // "汪汪" "汪汪"

// 修改原型
Dog.prototype.叫声 = '呜呜'; 
console.log(狗1.叫声, 狗2.叫声); // "呜呜" "呜呜" —— 全变了！

// ⚠️ 但修改实例自己的属性不会
狗1.叫声 = '嗷嗷'; // 给狗1自己加属性，不修改原型
console.log(狗1.叫声); // "嗷嗷"
console.log(狗2.叫声); // "呜呜" —— 不变
```

**关键**：读取时向上找，写入时直接写自己身上。原型是只读共享的。

---

### **6. "constructor属性判断类型"**
```javascript
function Person() {}
let p = new Person();

console.log(p.constructor === Person); // true —— 通过constructor认爹
console.log(p instanceof Person); // true —— 更常用的判断方式
```

---

## **二、面试官怎么考？高频题型**

### **题型1：代码输出题（必考）**
```javascript
function Fn() {}
Fn.prototype.a = 1;

let obj1 = new Fn();
Fn.prototype = { a: 2 };
let obj2 = new Fn();

console.log(obj1.a, obj2.a); // 问输出什么？
```
**考点**：`new`的时候快照了当时的原型，后续修改`prototype`不影响已创建的实例。

**答案**：`1, 2`

---

### **题型2：手写原型链继承**
```javascript
// 问：如何让Child继承Parent的方法？
function Parent() { this.name = 'parent'; }
Parent.prototype.say = function() {};

function Child() { this.age = 18; }
// 你的代码？
```
**考点**：是否懂`prototype`赋值和构造函数借调。

**标准答案**：
```javascript
// 方法1：经典原型链
Child.prototype = new Parent(); // 继承方法
Child.prototype.constructor = Child; // 修复constructor

// 方法2：寄生组合式（最佳）
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;
Parent.call(this); // 在Child内部借调Parent构造函数
```

---

### **题型3：`__proto__` vs `prototype`**
**问题**：这两个属性有什么区别？

**考点**：是否理解实例与构造函数的区别。

**回答**：
- `prototype`是**构造函数**的属性，用来给**实例**共享方法
- `__proto__`是**实例**的属性，指向创建它的构造函数的`prototype`
- `实例.__proto__ === 构造函数.prototype`

---

### **题型4：箭头函数的原型**
```javascript
let obj = {
    foo: () => {}
};
console.log(obj.foo.prototype); // 输出什么？
```
**考点**：箭头函数没有`prototype`，不能被`new`。

**答案**：`undefined`

---

## **三、面试回答模板（分层次）**

### **基础回答（应届生/初级）**
> "原型链是JavaScript实现继承的机制。每个对象都有`__proto__`指向它的原型对象，查找属性时会一层层向上直到`Object.prototype`。这样可以把公共方法放在原型上节省内存，比如`Array.prototype.push`就是所有数组共享的。"

### **进阶回答（1-3年经验）**
> "JavaScript通过原型链实现基于原型的继承。关键点是：1) 实例的`__proto__`指向构造函数的`prototype`；2) 属性查找是单向向上搜索；3) 写入属性始终写在实例本身；4) 最佳继承实践是寄生组合式，避免直接`new Parent()`带来的副作用。现代ES6的`class`语法糖底层还是这个原理。"

### **专家回答（资深）**
> "原型链是JS对象系统的核心，它实现了委托机制而非传统继承。我会关注：1) `[[Prototype]]`的内部槽位与`__proto__`访问器的区别；2) `prototype`属性的不可枚举性；3) 动态修改原型对性能的影响（会触发V8的deopt）；4) `Object.setPrototypeOf`与直接赋值的区别；5) 现代模式下优先使用`Object.create`和`class extends`避免原型污染问题。"

---

## **四、回答禁忌（别踩坑）**

❌ **不要说**："JavaScript是面向对象语言，有类继承"  
✅ **要说**："JavaScript是基于原型的语言，通过原型链实现类似继承的效果"

❌ **不要说**："修改`__proto__`来改变原型"（太老）  
✅ **要说**："使用`Object.setPrototypeOf`或`Object.create`"

❌ **不要混淆**：`prototype`和`__proto__`  
✅ **要强调**：一个是给实例用的，一个是实例自己的

❌ **不要忽略**：`constructor`属性需要修复  
✅ **要提到**：重写`prototype`后记得`constructor = 构造函数`

---

**最后提醒**：原型链题目一定要画图！面试时主动说"我可以画一下查找路径吗"，然后画：

```
实例对象 → __proto__ → 构造函数.prototype → __proto__ → Object.prototype → null
```



## 实现寄生组合继承

不用怕，寄生组合继承其实就像**"家族传承仪式"**，我会用父子分家的故事，把每句代码讲成生活场景：

---

## **第一步：创建父类（建立家族基业）**

```javascript
function Parent(name) {
  this.name = name;
  this.colors = ['red', 'green', 'blue'];
}
```
**解读**：这是"爸爸"的的人生规划。每个爸爸实例都有自己的`name`（名字）和`colors`（喜欢的颜色），这是**私人财产**，不能共享。

```javascript
Parent.prototype.sayName = function() {
  console.log(this.name);
};
```
**解读**：爸爸把"自我介绍"这个技能写进了**家族秘籍**（`prototype`），所有子女都可以**免费学习**，不用每个人都重新发明一遍。这是**公共财产**。

---

## **第二步：创建子类（儿子独立门户）**

```javascript
function Child(name, age) {
  Parent.call(this, name);
  this.age = age;
}
```
**这是最关键的一步，拆开讲：**

- `Parent.call(this, name)`：**儿子结婚前，先请爸爸来帮忙建房子**
  - `call`是"借用"的意思，儿子对爸爸说："爸，你把你建房子的技术借我用用，但我要建在自己家地盘（`this`）上"
  - 这样儿子的实例就有了自己的`name`和`colors`，但**没有**继承爸爸的`sayName`方法（因为方法在秘籍上，不在建房子流程里）

- `this.age = age`：**儿子自己的特色**，爸爸没有年龄属性，这是新生代才有的。

**生活比喻**：儿子分家时，把爸爸的"私人存款"（构造函数里的属性）复制了一份，但爸爸的"祖传手艺"（原型方法）还没传下来。

---

## **第三步：继承祖传手艺（核心黑科技）**

```javascript
Child.prototype = Object.create(Parent.prototype);
```
**这句代码是整个寄生组合的精髓！**

**错误做法对比**：
```javascript
// ❌ 传统做法：直接new一个爸爸
Child.prototype = new Parent(); 
// 副作用：new Parent()会执行构造函数，给prototype加上name、colors等无用属性
```

**正确做法解读**：
- `Object.create(Parent.prototype)`：**儿子去复印店，只复印爸爸的秘籍封面和目录**（原型链关系），**不复印爸爸的人生经历**（不执行构造函数）
- 这样儿子就获得了使用`sayName`的权利，但不会在原型上多出一堆`name`、`colors`的污染属性

```javascript
Child.prototype.constructor = Child;
```
**解读**：复印完秘籍后，封面上的"作者"还是爸爸的名字，需要手动改成儿子的名字。否则`child1.constructor`会错误地指向`Parent`。

---

## **第四步：添加儿子自己的新方法**

```javascript
Child.prototype.sayAge = function() {
  console.log(this.age);
};
```
**解读**：儿子在复印来的秘籍**空白页**上，写下自己的新技能`sayAge`。这样既保留了爸爸的手艺，又扩展了自己的特色。

---

## **完整流程串讲（可朗读版）**

```javascript
function Parent(name) {
  this.name = name;
  this.colors = ['red', 'green', 'blue'];
}
Parent.prototype.sayName = function() {
  console.log(this.name);
};

function Child(name, age) {
  Parent.call(this, name);  // 儿子借爸爸的技术建自己的房子（继承属性）
  this.age = age;           // 儿子自己的特色
}

Child.prototype = Object.create(Parent.prototype);  // 儿子只复印爸爸的秘籍（继承方法）
Child.prototype.constructor = Child;                // 修改作者署名
Child.prototype.sayAge = function() {               // 儿子在秘籍上加新技能
  console.log(this.age);
};

var child1 = new Child('Tom', 18);
child1.sayName(); // 'Tom'  —— 用爸爸的祖传手艺
child1.sayAge();  // 18     —— 用自己的新手艺
```

---

## **为什么叫"寄生组合"？**

- **寄生**：儿子像寄生虫一样，从爸爸那里"偷"来了原型链关系（`Object.create`），但没有让爸爸"怀孕"（不执行构造函数）
- **组合**：结合了  **"构造函数继承"**  （`Parent.call`）和  **"原型链继承"**  （`Object.create`）两种方式的优点

---

## **面试回答模板（背诵版）**

> "寄生组合继承是JS最经典的继承模式。核心步骤是：1) 在子类构造函数中用`Parent.call(this)`继承父类实例属性；2) 用`Object.create(Parent.prototype)`创建新对象作为子类原型，避免调用父类构造函数；3) 修复`constructor`指向；4) 在子类原型上扩展新方法。这样既实现了属性隔离，又实现了方法共享，效率最高，没有副作用。"

---

**一句话总结**：儿子分家时，**只抄爸爸的祖传秘籍，不抄爸爸的房产证**，然后在自己的房产证上加名字。

## instanceof 原理
