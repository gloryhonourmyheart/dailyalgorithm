# [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)





提示



给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：**你不能倾斜容器。

 

**示例 1：**

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**

```
输入：height = [1,1]
输出：1
```

 

**提示：**

- `n == height.length`
- `2 <= n <= 105`
- `0 <= height[i] <= 104`



### 题目分析

**问题核心**：在坐标轴上找两条垂直线，与x轴构成容器，使得容纳的水量最大。

**容量计算**：两根线 `i` 和 `j` 构成的容量 = `min(height[i], height[j]) × (j - i)`
- `min(height[i], height[j])` 是由较短线决定的水位高度
- `(j - i)` 是两条线之间的距离（宽度）

---

### 一、暴力解法（Brute Force）

**思路**：穷举所有可能的线对组合。

```javascript
// 暴力法：双层循环遍历所有组合
var maxArea = function(height) {
    let max = 0;
    // 外层循环：固定左边界
    for (let left = 0; left < height.length; left++) {
        // 内层循环：遍历所有右边界
        for (let right = left + 1; right < height.length; right++) {
            // 计算当前容器的容量
            let area = Math.min(height[left], height[right]) * (right - left);
            // 更新最大值
            max = Math.max(max, area);
        }
    }
    return max;
};
```

**复杂度**：
- 时间复杂度：O(n²) — 遍历所有 C(n,2) 种组合
- 空间复杂度：O(1)
- **缺点**：当 n = 10⁵ 时，约 50 亿次运算，严重超时

---

### 二、优化思路（下意识应想到的）

**关键观察**：

1. **容量取决于短板**：水位高度由两根线中较短的决定
2. **宽度越远越好**：两根线距离越远，容量潜力越大
3. **移动长板无益**：如果移动较高的线，宽度减小，高度仍受限于短线，容量必定减小
4. **移动短线可能优化**：移动较短的线，虽然宽度减小，但高度可能增加，存在找到更大容量的可能

**算法选择**：**双指针法**（Two Pointers）- 典型的 O(n) 解法

---

### 三、最优算法（双指针）

**核心思想**：从两端开始向中间收敛，每次移动较短的那条线

```javascript
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
    // 初始化左右指针：一个在开头，一个在结尾
    let left = 0;
    let right = height.length - 1;
    // 初始化最大容量为 0
    let maxArea = 0;

    // 当两指针未相遇时持续遍历
    while (left < right) {
        // 计算当前容量：短板高度 × 宽度
        let currentArea = Math.min(height[left], height[right]) * (right - left);
        
        // 更新历史最大容量
        maxArea = Math.max(maxArea, currentArea);
        
        // 移动较短的指针（关键决策）
        if (height[left] < height[right]) {
            // 左指针线较短，向右移动寻找更高的线
            left++;
        } else {
            // 右指针线较短或相等，向左移动寻找更高的线
            right--;
        }
    }
    
    // 返回找到的最大容量
    return maxArea;
};
```

**逐行解析**：

| 行号 | 代码                                                | 解析                                   |
| ---- | --------------------------------------------------- | -------------------------------------- |
| 1    | `let left = 0;`                                     | 左指针从数组起始位置开始               |
| 2    | `let right = height.length - 1;`                    | 右指针从数组末尾开始，确保初始宽度最大 |
| 3    | `let maxArea = 0;`                                  | 初始化最大容量为 0                     |
| 5    | `while (left < right)`                              | 循环条件：两指针未相遇                 |
| 7    | `let currentArea = Math.min(...) * (right - left);` | 计算当前容量：短板原则 × 宽度          |
| 10   | `maxArea = Math.max(maxArea, currentArea);`         | 保留历史最大值                         |
| 13   | `if (height[left] < height[right])`                 | **核心逻辑**：比较两根线高度           |
| 15   | `left++;`                                           | 左线短，右移寻找可能更高的线           |
| 17   | `right--;`                                          | 右线短，左移寻找可能更高的线           |
| 20   | `return maxArea;`                                   | 返回结果                               |

---

### 四、无注释版代码

```javascript
var maxArea = function(height) {
    let left = 0;
    let right = height.length - 1;
    let maxArea = 0;
    
    while (left < right) {
        let currentArea = Math.min(height[left], height[right]) * (right - left);
        maxArea = Math.max(maxArea, currentArea);
        
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    
    return maxArea;
};
```

**复杂度分析**：
- **时间复杂度**：O(n) — 指针最多移动 n 次
- **空间复杂度**：O(1) — 仅使用常数个变量
- **正确性保证**：每次移动都保留了可能的最大值候选

---

### 五、为什么这样一定正确？

**证明思路**：
- **初始状态**：包含全局最优解的可能性（因为未排除任何情况）
- **移动操作**：每次淘汰掉不可能更优的解（移动短线时，所有包含该线的其他组合容量都更小）
- **终止状态**：遍历完所有有潜力的组合，必找到全局最优

这种贪心策略巧妙地剪枝了不可能成为最优解的分支，将 O(n²) 的搜索空间降为 O(n)。