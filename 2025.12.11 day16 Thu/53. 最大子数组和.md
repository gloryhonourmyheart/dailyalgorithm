# 53.最大子数组和



给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组是数组中的一个连续部分。

 

示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]

输出：6

解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

示例 2：

输入：nums = [1]

输出：1

示例 3：

输入：nums = [5,4,-1,7,8]

输出：23

 

提示：

1 <= nums.length <= 105

-104 <= nums[i] <= 104

 

进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。

/**

 \* @param {number[]} nums

 \* @return {number}

 */

var maxSubArray = function(nums) {

  

};





## 题目分析：最大子数组和

### 一、拿到题目后的分析思路

**第一步：理解题意**
- 子数组要求是**连续的**
- 至少要包含一个元素（即使数组全是负数）
- 需要返回的是**最大和**，而不是子数组本身

**第二步：思考暴力解法**
- 最直观的方法：枚举所有可能的连续子数组
- 计算每个子数组的和
- 找出其中的最大值

**第三步：寻找优化方向**
- 暴力法时间复杂度是O(n²)，题目数据量最大10⁵，会超时
- 观察发现：如果当前子数组和为负数，它对后续元素只有拖累作用
- 关键洞察：**当当前和<0时，应该果断丢弃，从下一位重新开始计算**

### 二、暴力算法详解（O(n²)）

```javascript
// 暴力法思路：双层循环枚举所有子数组
var maxSubArrayBruteForce = function(nums) {
    let maxSum = nums[0]; // 初始化最大和为第一个元素
    
    // 外层循环：子数组的起始位置
    for (let i = 0; i < nums.length; i++) {
        let currentSum = 0; // 当前子数组的和
        
        // 内层循环：从起始位置i开始，逐步扩展子数组
        for (let j = i; j < nums.length; j++) {
            currentSum += nums[j]; // 累加当前元素
            
            // 如果当前和大于历史最大和，更新最大值
            if (currentSum > maxSum) {
                maxSum = currentSum;
            }
        }
    }
    
    return maxSum;
};
```

**时间复杂度**：O(n²) - 两层循环  
**空间复杂度**：O(1)

### 三、最优算法：Kadane算法（O(n)）

**核心思想**：动态规划 + 贪心思想

**算法逻辑**：
- 遍历数组时维护两个变量：
  - `currentSum`：当前子数组的和
  - `maxSum`：全局最大和
- **关键决策点**：如果`currentSum`变为负数，立即重置为0
  - 因为负数会拖累后续元素的和，不如"断舍离"重新开始

**算法演示**（以`[-2,1,-3,4,-1,2,1,-5,4]`为例）：

| 索引 | nums[i] | currentSum | maxSum | 说明                  |
| ---- | ------- | ---------- | ------ | --------------------- |
| 0    | -2      | 0          | -2     | currentSum<0，重置为0 |
| 1    | 1       | 1          | 1      | currentSum=1>0        |
| 2    | -3      | -2         | 1      | currentSum<0，重置为0 |
| 3    | 4       | 4          | 4      | 重新开始              |
| 4    | -1      | 3          | 4      | 继续累加              |
| 5    | 2       | 5          | 5      |                       |
| 6    | 1       | 6          | 6      | **找到最大值**        |
| 7    | -5      | 1          | 6      |                       |
| 8    | 4       | 5          | 6      |                       |

### 四、面试现场手写代码（带逐行注释）

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    // 初始化两个关键变量
    let currentSum = 0;  // 当前连续子数组的和，初始为0
    let maxSum = nums[0]; // 全局最大和，初始化为数组第一个元素
                         // 为什么设nums[0]？确保即使全负数也能返回正确值
    
    // 遍历数组中的每个元素
    for (let i = 0; i < nums.length; i++) {
        // 核心逻辑1：累加当前元素到currentSum
        currentSum += nums[i];
        
        // 核心逻辑2：更新全局最大和
        // 如果当前子数组和比历史最大和还大，就更新maxSum
        if (currentSum > maxSum) {
            maxSum = currentSum;
        }
        
        // 核心逻辑3：关键决策点！
        // 如果currentSum变成负数，果断丢弃，重置为0
        // 因为负数会拖累后续元素，不如重新开始
        // 为什么<=0？因为0不会影响后续累加结果
        if (currentSum <= 0) {
            currentSum = 0;
        }
    }
    
    // 返回遍历结束后找到的全局最大和
    return maxSum;
};
```

### 五、代码逐行解读

```javascript
// 初始化当前和为0（准备重新开始累加）
let currentSum = 0;

// 初始化最大和为第一个元素
// 这里不能设为0，考虑全负数情况如[-1,-2]，正确答案应是-1
let maxSum = nums[0];

// 遍历数组每个元素
for (let i = 0; i < nums.length; i++) {
    // 把当前元素加到currentSum上
    currentSum += nums[i];
    
    // 比较并更新最大和
    if (currentSum > maxSum) {
        maxSum = currentSum;
    }
    
    // 关键：如果currentSum变为负数或0，重置为0
    // 这相当于"砍掉"前面的负和，从下一位重新开始
    if (currentSum <= 0) {
        currentSum = 0;
    }
}

// 返回结果
return maxSum;
```

### 六、无注释版代码（面试最终版）

```javascript
var maxSubArray = function(nums) {
    let currentSum = 0;
    let maxSum = nums[0];
    
    for (let i = 0; i < nums.length; i++) {
        currentSum += nums[i];
        
        if (currentSum > maxSum) {
            maxSum = currentSum;
        }
        
        if (currentSum <= 0) {
            currentSum = 0;
        }
    }
    
    return maxSum;
};
```

### 七、面试加分技巧

1. **先说暴力法**：展示基础思维，O(n²)复杂度
2. **画图分析**：在纸上画出数组和累加过程
3. **提出优化**："我注意到如果当前和为负，会拖累后续..."
4. **边写边讲**：每写一行代码，口头解释其作用
5. **测试用例**：主动提出用`[-2,1,-3,4,-1,2,1,-5,4]`走一遍流程
6. **边界情况**：提到全负数、单个元素、全正数等情况

**进阶**：如果面试官要求分治法，可以说明：
- 分治法的核心是找出跨越左右两部分的子数组和
- 时间复杂度O(nlogn)，代码更复杂但思路清晰
- 实际工程中Kadane算法更常用

---

**时间复杂度**：O(n) - 只需遍历一次数组  
**空间复杂度**：O(1) - 只使用了两个变量  
**最优性**：该算法是理论最优解，无法进一步优化



# 面试手搓：最大子数组和（Kadane算法）

## 一、题目理解速记
**核心要求**：找连续子数组的最大和，至少包含一个元素

**关键洞察**：负数前缀会拖累后续和，必须果断丢弃

---

## 二、分析思路（面试话术）
> "我先从暴力法入手，枚举所有子数组，但发现是O(n²)会超时。然后观察到关键性质：**如果当前累加和变负，它只会拖累后面元素**，不如归零重来。这引导我想到Kadane算法，一次遍历就能搞定。"

---

## 三、暴力解法（展示思维过程）
```javascript
var maxSubArrayBruteForce = function(nums) {
    let maxSum = nums[0];
    
    for (let i = 0; i < nums.length; i++) {
        let currentSum = 0;
        for (let j = i; j < nums.length; j++) {
            currentSum += nums[j];
            if (currentSum > maxSum) maxSum = currentSum;
        }
    }
    return maxSum;
};
// 时间O(n²)，空间O(1) —— 用于面试时展示基础思维
```

---

## 四、最优解：Kadane算法

### 4.1 核心思想
**贪心决策**：`currentSum <= 0`时立即归零，断舍离负资产

**数学本质**：动态规划状态转移
```
dp[i] = max(nums[i], dp[i-1] + nums[i])
```

### 4.2 完整带注释版（面试手写）
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    // 初始化：当前和清零，最大和取首元素（防全负数）
    let currentSum = 0;      // 🎯 当前子数组累加和
    
    // 为什么初始化为nums[0]？
    // 如果全负数如[-1,-2,-3]，正确答案应是-1，不是0
    let maxSum = nums[0];    // 🎯 全局最大和
    
    // 一次遍历：每个元素只看一遍 → 线性时间O(n)
    for (let i = 0; i < nums.length; i++) {
        // 核心1：累加当前元素
        currentSum += nums[i];
        
        // 核心2：尝试更新全局最大和
        if (currentSum > maxSum) {
            maxSum = currentSum;  // 找到更好的解
        }
        
        // 🔥 核心3：关键决策点！负数和清零
        // 如果currentSum<=0，说明当前子数组是负资产
        // 会拖累后续元素，果断丢弃从下一位重新开始
        // 为什么<=0？因为0不影响后续累加，且代码更简洁
        if (currentSum <= 0) {
            currentSum = 0;  // 归零！断舍离！
        }
    }
    
    return maxSum;  // 返回遍历结果
};
```

### 4.3 无注释简洁版（面试终稿）
```javascript
var maxSubArray = function(nums) {
    let currentSum = 0;
    let maxSum = nums[0];
    
    for (let i = 0; i < nums.length; i++) {
        currentSum += nums[i];
        if (currentSum > maxSum) maxSum = currentSum;
        if (currentSum <= 0) currentSum = 0;
    }
    
    return maxSum;
};
```

---

## 五、逐行心智模型（快速记忆）

| 代码行                     | 记忆口诀       | 生活类比     |
| -------------------------- | -------------- | ------------ |
| `currentSum = 0`           | 新公司初始资金 | 创业启动资金 |
| `maxSum = nums[0]`         | 历史最佳业绩   | 公司最高市值 |
| `currentSum += nums[i]`    | 今日营收入账   | 今日公司收入 |
| `if (currentSum > maxSum)` | 刷新纪录       | 超越历史峰值 |
| `if (currentSum <= 0)`     | 公司破产清算   | 连续亏损关门 |
| `currentSum = 0`           | 重新创业       | 从零开始     |

---

## 六、关键概念速查

### 6.1 线性时间 O(n)
- **定义**：操作次数 ≈ 数据量，一条直线
- **识别**：单层循环，`for (let i = 0; i < n; i++)`
- **对比**：O(n²)是嵌套循环，for套for

### 6.2 枚举（Enumerating）
- **本质**：一个一个列出来，穷举所有可能
- **例子**：双层枚举所有子数组`[i...j]`

### 6.3 贪心思想（Greedy）
- **核心**：只看当前最优，不顾全局影响
- **本题**：currentSum变负立即扔，**及时止损**

### 6.4 分治法 vs Kadane
| 维度   | 分治法     | Kadane   |
| ------ | ---------- | -------- |
| 思想   | 切两半递归 | 一次遍历 |
| 复杂度 | O(n log n) | **O(n)** |
| 空间   | O(log n)   | **O(1)** |
| 适用   | 通用思想   | 本题最优 |

---

## 七、面试现场表达模板

**开场**：
> "这道题我想到三个解法：暴力O(n²)作为baseline，Kadane算法O(n)作为最优解，如果面试官想考察递归思维，我也可以用分治法O(nlogn)实现。"

**写代码时**：
```javascript
// 边写边讲：
let currentSum = 0;      // 当前子数组和
let maxSum = nums[0];    // 全局最大和，初始化为首元素防全负

for (let i = 0; i < nums.length; i++) {
    currentSum += nums[i];  // 累加当前元素
    
    if (currentSum > maxSum) {  // 尝试更新最大值
        maxSum = currentSum;
    }
    
    // 🔥 核心决策：负数清零
    if (currentSum <= 0) {
        currentSum = 0;  // 负资产拖累后续，断舍离
    }
}
```

**收尾**：
> "时间复杂度O(n)，每个元素只访问一次；空间复杂度O(1)，只用了两个变量。这是理论最优解，因为必须至少看一遍数组才能确定答案。"

---

## 八、高频追问应对

### Q1: 为什么 `maxSum` 初始化为 `nums[0]` 而不是 `0`?
**答**："如果数组全负数如`[-1,-2,-3]`，答案应该是`-1`（最大子数组和为单个元素）。若初始化为`0`，会错误返回`0`。初始化为`nums[0]`覆盖所有情况。"

### Q2: 为什么判断 `currentSum <= 0` 而不是 `< 0`?
**答**："两个原因：
1. **数学上**：`0`不影响后续累加，`0 + x = x`
2. **代码上**：统一处理负数和零，逻辑更简洁
3. **结果上**：结论不变，因为零本身不可能是最大和（除非全零）"

### Q3: 如果数组全正数呢？这个算法还生效吗？
**答**："生效。全正数时`currentSum`永远不会清零，会一直累加，最终`maxSum`就是整个数组的和。算法自动退化为求总和。"

### Q4: 返回子数组本身，怎么做？
**答**："记录起始索引即可"（现场写变种代码）

### Q5: 分治法怎么实现？
**答**："最大子数组要么全在左，要么全在右，要么跨中间。递归求解左右，中间情况从mid向左/右分别扫描找最大，三者取最大。"（现场画递归树）

---

## 九、记忆口诀

**终极背诵版**：
```
currentSum清零，maxSum取首
遍历数组，累加当前
更大就更新，负了就归零
一次走完，答案到手
```

---

## 十、代码对比卡（面试时画在草稿纸）

```
暴力法: 🐌 O(n²)  嵌套for循环
        for i
          for j
            sum += nums[j]

Kadane: 🚀 O(n)   单层for循环
        for i
          sum += nums[i]
          if sum>max: max=sum
          if sum<=0: sum=0
```

**选择**：数据量10⁵时，O(n²)=100亿次操作（超时），O(n)=10万次（轻松通过）