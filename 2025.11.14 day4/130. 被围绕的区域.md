# 130. 被围绕的区域
给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' 组成，捕获 所有 被围绕的区域：

连接：一个单元格与水平或垂直方向上相邻的单元格连接。
区域：连接所有 'O' 的单元格来形成一个区域。
围绕：如果您可以用 'X' 单元格 连接这个区域，并且区域中没有任何单元格位于 board 边缘，则该区域被 'X' 单元格围绕。
通过 原地 将输入矩阵中的所有 'O' 替换为 'X' 来 捕获被围绕的区域。你不需要返回任何值。

 

示例 1：

输入：board = [['X','X','X','X'],['X','O','O','X'],['X','X','O','X'],['X','O','X','X']]

输出：[['X','X','X','X'],['X','X','X','X'],['X','X','X','X'],['X','O','X','X']]

解释：


在上图中，底部的区域没有被捕获，因为它在 board 的边缘并且不能被围绕。

示例 2：

输入：board = [['X']]

输出：[['X']]

 

提示：

m == board.length
n == board[i].length
1 <= m, n <= 200
board[i][j] 为 'X' 或 'O'



## 📌 一、题目速记口诀
**"边缘安全区标记，中间捕获，最后恢复"**

## 📋 二、核心要点自查清单

在面试前，确保你能回答以下问题：

### 1. 题目理解
- [ ] 什么是"被围绕的区域"？**答：完全被'X'包围且不接触边缘的'O'连通块**
- [ ] 逆向思维是什么？**答：先找安全的（边缘相连的'O'），剩下的就是被围绕的**
- [ ] 为什么用'#'标记？**答：区分两种'O'，避免使用额外空间**

### 2. 算法选择
- [ ] 暴力算法的时间复杂度？**答：O(m²n²)，重复访问严重**
- [ ] 最优算法的时间复杂度？**答：O(mn)，每个单元格最多访问一次**
- [ ] 为什么最优算法更快？**答：从边缘开始，一次DFS标记整个安全区域**

### 3. 代码结构
- [ ] 三段式结构？**答：①标记边缘 ②全盘处理 ③恢复安全区**
- [ ] DFS函数的作用？**答：递归标记所有相连的'O'为'#'**
- [ ] 为什么左右边缘循环从`i=1`开始？**答：避免重复处理四个角**

---

## 💡 三、最优算法 - 完整代码（面试时手写版）
```javascript
/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solve = function(board) {
    if (!board || board.length === 0 || board[0].length === 0){
        return;
    }
    const m = board.length;
    const n = board[0].length;
    function dfs(i,j){
        if(i<0 || i>= m || j<0 || j>=n){
            return;
        }
        if(board[i][j] !== 'O'){
            return;
        }
        board[i][j] = '#';
        dfs(i - 1, j);
        dfs(i + 1, j);
        dfs(i, j - 1);
        dfs(i, j + 1);
    }
    for(let j = 0; j<n;j++){
        if(board[0][j] === 'O'){
            dfs(0,j);
        }
        if(board[m - 1][j] === 'O'){
            dfs(m - 1, j);
        }
    }
    for(let i = 1;i< m - 1; i++){
        if(board[i][0] === 'O'){
            dfs(i,0);
        }
        if(board[i][n - 1] === 'O'){
            dfs(i,n-1);
        }
    }
    for(let i = 0;i<m;i++){
        for (let j = 0;j<n;j++){
            if(board[i][j] === '#'){
                board[i][j] = 'O';
            }
            else if (board[i][j] === 'O'){
                board[i][j] = 'X';
            }
        }
    }
};
```
```javascript
var solve = function(board) {
    // 边界检查（防呆）
    if (!board || board.length === 0 || board[0].length === 0) return;
    
    const m = board.length;     // 行数
    const n = board[0].length;  // 列数
    
    // 1️⃣ DFS函数：标记安全区域
    function dfs(i, j) {
        // 越界检查
        if (i < 0 || i >= m || j < 0 || j >= n) return;
        // 不是'O'就返回（包括已标记的'#'）
        if (board[i][j] !== 'O') return;
        
        board[i][j] = '#';  // 标记为安全
        
        // 四个方向扩散
        dfs(i - 1, j);  // 上
        dfs(i + 1, j);  // 下
        dfs(i, j - 1);  // 左
        dfs(i, j + 1);  // 右
    }
    
    // 2️⃣ 从四条边开始标记
    // 上下边缘
    for (let j = 0; j < n; j++) {
        if (board[0][j] === 'O') dfs(0, j);
        if (board[m - 1][j] === 'O') dfs(m - 1, j);
    }
    // 左右边缘（避开角）
    for (let i = 1; i < m - 1; i++) {
        if (board[i][0] === 'O') dfs(i, 0);
        if (board[i][n - 1] === 'O') dfs(i, n - 1);
    }
    
    // 3️⃣ 全盘处理：安全区恢复，危险区捕获
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (board[i][j] === '#') board[i][j] = 'O';  // 安全
            else if (board[i][j] === 'O') board[i][j] = 'X';  // 捕获
        }
    }
};
```

---

## 🔍 四、面试高频问题 & 标准答案

### Q1: 为什么 `const n = board[0].length` 能获取列数？
**A**: `board`是二维数组，`board[0]`是第一行数组，它的`length`就是列数。所有行长度相同。

### Q2: DFS和遍历是什么关系？
**A**: **遍历是触发器，DFS是扩展器**。遍历找到起点，DFS标记整个连通区域。二者协作，缺一不可。

### Q3: 遍历顺序可以改为列到行吗？
**A**: **完全可以**。只要每个单元格被访问到，顺序不影响结果。行到列更符合习惯和内存布局。

### Q4: 左右边缘循环为什么从`i=1`开始？
**A**: **避免重复处理四个角**。四个角已在上下边缘循环处理过，跳过可提升效率。

### Q5: 重复处理边缘会出错吗？
**A**: **不会出错，但效率低**。DFS有`board[i][j] !== 'O'`保护，重复调用直接返回。

---

## 🎯 五、面试现场技巧

### 1. 先讲思路，再写代码
**话术模板**：
> "这道题用逆向思维：不找被围绕的，而找安全的。从四条边的'O'开始DFS标记，剩下的'O'就是被围绕的，最后统一处理。时间复杂度O(mn)，空间O(mn)。"

### 2. 代码书写顺序
1. **边界检查**（10秒写完）
2. **DFS函数**（核心，先写框架，再补细节）
3. **边缘遍历**（上下 → 左右）
4. **全盘处理**（双重循环）

### 3. 易错点提醒
- **DFS别忘记边界检查**
- **左右边缘避开角**（`i=1`到`m-2`）
- **最后处理时`'#'`恢复`'O'`在前，`'O'`变`'X'`在后**

---

## ✅ 六、自我检测 - 不看代码能写出吗？

请闭眼默念或手写以下部分：

### 1. DFS函数骨架
```javascript
function dfs(i, j) {
    if (/*越界*/) return;
    if (board[i][j] !== 'O') return;
    board[i][j] = '#';
    /*四个方向*/
}
```

### 2. 边缘遍历顺序
```javascript
// 先上下，后左右
for (let j = 0; j < n; j++) { /*上下*/ }
for (let i = 1; i < m - 1; i++) { /*左右，跳过角*/ }
```

### 3. 最终处理逻辑
```javascript
for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
        if (board[i][j] === '#') /*变O*/;
        else if (board[i][j] === 'O') /*变X*/;
    }
}
```

---

## 📝 七、总结背诵版

**最优算法 = 逆向思维 + DFS + 三段式**

1. **逆向**：先标记安全的（边缘相连），剩下的就是被围绕的
2. **DFS**：从边缘'O'出发，递归标记所有相连的'O'为'#'
3. **三段式**：标记边缘 → 全盘处理 → 恢复安全区

**复杂度**：时间O(mn)，空间O(mn)（递归栈）

**面试必答**：为什么左右边缘从`i=1`开始？**答：避免四个角重复处理，提升效率。**

---

## 🎯 八、自我检查清单

下次写代码时，**逐行检查**以下内容：

- [ ] 所有 `'O'` 是**字母O**，不是**数字0**
- [ ] 所有 `'X'` 是**大写X**，不是**小写x**
- [ ] 边界检查 `i >= m` 和 `j >= n` 是否正确
- [ ] DFS函数中是否有 `board[i][j] !== 'O'` 的保护
- [ ] 边缘循环是否从 `i=1` 开始避开角
- [ ] 最后一步是否先恢复 `'#'` 再捕获 `'O'`

**建议**：下次写完代码后，**全文搜索**所有 `'0'` 和 `'x'`，确保没有误用！

---

## 💡 九、调试技巧

如果以后代码不工作，按这个顺序检查：

1. **console.log(board)** 看输入是否正确
2. **在dfs第一行** `console.log('dfs', i, j, board[i][j])` 看是否被调用
3. **检查字符**：`console.log('"' + board[i][j] + '"')` 确认是'O'还是'0'



Depth-First Search