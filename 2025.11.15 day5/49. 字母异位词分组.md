# 49. 字母异位词分组

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。


示例 1:

输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]

输出: [["bat"],["nat","tan"],["ate","eat","tea"]]

解释：

在 strs 中没有字符串可以通过重新排列来形成 "bat"。字符串 "nat" 和 "tan" 是字母异位词，因为它们可以重新排列以形成彼此。字符串 "ate" ，"eat" 和 "tea" 是字母异位词，因为它们可以重新排列以形成彼此。

示例 2:

输入: strs = [""]

输出: [[""]]

示例 3:

输入: strs = ["a"]

输出: [["a"]]

 

提示：

1 <= strs.length <= 1040 <= strs[i].length <= 100strs[i] 仅包含小写字母



# 字母异位词分组 - 面试完全指南

## 一、题目核心理解（30秒讲给面试官）

**类比：按姓氏分组学生**
- 张小明、张小红 → 都姓"张" → 分到同一组
- "eat"、"tea"、"ate" → 排序后都是"aet" → 分到同一组

**核心突破口**：字母异位词排序后的"签名"相同，用这个签名作为分组依据。

---

## 二、三种解法对比（先展示思路广度）

| 算法类型 | 核心操作 | 时间复杂度 | 面试建议 |
|---------|---------|-----------|----------|
| **暴力法** | 两两比较 | O(n²×k) | 只提思路，不写代码 |
| **排序法** | 排序做键 | O(n×klogk) | **手搓首选**，代码简洁 |
| **计数法** | 计数签名 | **O(n×k)** | **最优解**，展示深度 |

---

## 三、手搓首选：排序法（最简实现）

```javascript
/**
 * 字母异位词分组 - 排序法
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function(strs) {
    // 1. 创建Map做哈希表：键=排序后签名，值=原始字符串数组
    const map = new Map();
    
    // 2. 遍历每个字符串
    for (let str of strs) {
        // 3. 生成签名：拆分为字符 → 排序 → 合并
        //    "eat" → ['e','a','t'] → ['a','e','t'] → "aet"
        let array = Array.from(str);  // 或 str.split('')
        array.sort();
        let key = array.toString();   // 或 array.join('')
        
        // 4. 分组：有则添加，无则创建
        //    map.get(key)获取已有数组，不存在就新建空数组
        let list = map.get(key) ? map.get(key) : new Array();
        list.push(str);
        map.set(key, list);
    }
    
    // 5. 返回所有分组
    return Array.from(map.values());  // values是复数！返回所有值的迭代器
};
```

**逐行记忆要点**：
- `new Map()` → 哈希表
- `Array.from(str).sort()` → 生成签名
- `map.get(key) || []` → 获取或创建
- `map.set(key, list)` → 存回Map
- `Array.from(map.values())` → 提取所有分组

---

## 四、最优解：字符计数法（展示技术深度）

```javascript
/**
 * 字母异位词分组 - 最优解（O(n×k)）
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function(strs) {
    const map = new Map();
    
    for (let str of strs) {
        // 1. 创建26字母计数器：[0,0,0,...,0]（26个0）
        const count = new Array(26).fill(0);
        
        // 2. 遍历字符串，统计每个字母出现次数
        //    "eat" → count[4]++ (e), count[0]++ (a), count[19]++ (t)
        for (let c of str) {
            // 核心：字符编码 - 'a'编码 = 0-25的索引
            count[c.charCodeAt() - 'a'.charCodeAt()]++;
        }
        
        // 3. 用计数数组作为键（会自动转为字符串"1,0,0,0,1,...,1"）
        //    相同异位词产生相同键
        map[count] ? map[count].push(str) : map[count] = [str];
    }
    
    return Object.values(map);  // 提取所有值
};
```

**关键难点解析**（面试官必问）：

### 1. `c.charCodeAt() - 'a'.charCodeAt()` 如何映射26个字母？

| 字母 | c.charCodeAt() | -97 | 结果索引 |
|------|----------------|-----|----------|
| 'a'  | 97             | -97 | **0**    |
| 'b'  | 98             | -97 | **1**    |
| 'e'  | 101            | -97 | **4**    |
| 'z'  | 122            | -97 | **25**   |

**本质**：利用Unicode编码连续性，把字母映射到数组的**门牌号**，数组值就是**计数器**。

### 2. 为什么用 `map.values()`？

- `map.values()` 返回**所有值**的迭代器（Iterator）
- Map有多个值，所以方法名用复数 `values`
- 对比：`map.keys()`、`map.entries()`都是复数
- 最后转为数组：`Array.from(迭代器)`

---

## 五、复杂度与边界情况

### 时间复杂度对比
- **排序法**：O(n × klogk) → 排序耗时
- **计数法**：O(n × k) → 每个字符只遍历一次（最优）

### 边界处理
```javascript
// 情况1：空字符串
strs = [""]
排序键 = ""
分组结果 = [[""]]

// 情况2：单个字符
strs = ["a"]
计数器 = [1,0,0,...,0]
分组结果 = [["a"]]

// 情况3：无异位词
strs = ["abc", "def"]
每个字符串签名唯一 → 各自成组
```

---

## 六、面试手搓口诀（背下来）

**排序法版本**：
```
Map来当本，排序做指纹
遍历每个串，有组就推进
无组新建群，最后取values
```

**计数法版本**：
```
26个0数组，遍历字符统计
编码减a得索引，对应位置自增
数组转字符串，当作Map的键
分组完毕取values，搞定收工
```

---

## 七、完整代码速记版（面试直接默写）

最简排序

``````javascript
var groupAnagrams = function(strs) {
    const map = new Map();

    for(let str of strs){
        const sorted = str.split('').sort().join('');//排序
        if(map.has(sorted)){
            map.get(sorted).push(str);
        } else{
            map.set(sorted,[str]);
        }
    }
    return Array.from(map.values());
};
``````



有注释版

```javascript
/**

 * @param {string[]} strs - 输入的字符串数组

 * @return {string[][]} - 分组后的二维数组
   */
   var groupAnagrams = function(strs) {
   // 1. 创建Map数据结构（哈希表），用于存储分组
   // 键：排序后的字符串（字母异位词的"指纹"）
   // 值：具有相同指纹的原始字符串数组
   const map = new Map();

   // 2. 遍历输入数组中的每一个字符串
   for (let str of strs) {
       // 3. 生成"指纹"（排序后的字符串）
       //    split('')  : 把字符串拆成字符数组，如 "eat" → ["e","a","t"]
       //    sort()     : 按字母顺序排序，["e","a","t"] → ["a","e","t"]
       //    join('')   : 把数组合并回字符串，["a","e","t"] → "aet"
       const sorted = str.split('').sort().join('');
       

       // 4. 检查这个"指纹"是否已存在于map中
       if (map.has(sorted)) {
           // 5. 【存在】将当前字符串加入对应分组
           //    map.get(sorted) 获取对应数组，然后 push 当前字符串
           map.get(sorted).push(str);
       } else {
           // 6. 【不存在】创建新分组，用数组存储当前字符串
           //    注意：值必须是数组，因为后续可能有多个字母异位词
           map.set(sorted, [str]);
       }

   }

   // 7. 返回结果：提取map中所有的值（分组数组）
   //    Array.from(map.values()) 将Map的所有值转换为数组
   return Array.from(map.values());
   };
```



后



```javascript
// 版本1：排序法（最稳妥）
var groupAnagrams = function(strs) {
    const map = new Map();
    for (let s of strs) {
        const key = s.split('').sort().join('');
        if (!map.has(key)) map.set(key, []);
        map.get(key).push(s);
    }
    return [...map.values()];  // 或 Array.from(map.values())
};

// 版本2：计数法（最优）
var groupAnagrams = function(strs) {
    const map = new Map();
    for (let s of strs) {
        const cnt = new Array(26).fill(0);
        for (let c of s) cnt[c.charCodeAt() - 97]++;
        const key = cnt.join('#');  // 显式用#分隔更安全
        if (!map.has(key)) map.set(key, []);
        map.get(key).push(s);
    }
    return [...map.values()];
};
```

---

## 八、面试官高频追问准备

**Q1: 为什么用Map不用Object？**  
A: Map键可以是任意类型，Object键会被转为字符串；Map的API更清晰，性能更好。

**Q2: 计数法中数组作为Object的键会发生什么？**  
A: 自动调用toString()转为逗号分隔的字符串，如[1,0,1]→"1,0,1"。

**Q3: 如果字符串包含大写字母怎么办？**  
A: 先转小写 `c.toLowerCase().charCodeAt()`，或扩大计数器到52位。

**Q4: 时间复杂度还能优化吗？**  
A: 计数法已是理论最优O(n×k)，因为必须遍历每个字符。

---

## 九、TODO LIST - 算法面试准备清单

### 📚 基础巩固阶段
- [ ] 刷完《剑指Offer》字符串章节所有题目（至少20道）
- [ ] 手写实现快速排序、归并排序各5遍（肌肉记忆）
- [ ] 掌握JavaScript Map/Set所有API及与Object的对比
- [ ] 理解Unicode编码，手写charCodeAt与fromCharCode转换

### 🎯 专项突破阶段
- [ ] LeetCode 49 本题的排序法 + 计数法各刷10遍
- [ ] 完成所有"字母异位词"相关题目（242, 438, 49,  group-anagrams）
- [ ] 模拟面试：5分钟内手撕本题两种解法 + 复杂度分析
- [ ] 总结常见数据结构的键值操作陷阱（如数组作为Object键）

### 🚀 进阶提升阶段
- [ ] 研究字符计数法的变种：用质数乘法代替计数（防哈希冲突）
- [ ] 刷完哈希表/Map相关所有中等题（至少30道）
- [ ] 练习在纸上手写代码（无IDE无语法提示）
- [ ] 准备3个本题的类比故事（姓氏分组、指纹分类等）

### 📝 面试前日检清单
- [ ] 复习本题代码3遍（能默写无错误）
- [ ] 回顾Unicode字母表编码范围（a-z: 97-122）
- [ ] 确认Map.values()与Object.values()的区别
- [ ] 准备至少2种复杂度优化思路（时间换空间/空间换时间）

### 🎤 模拟面试实战记录
- [ ] 第1次：____月____日，耗时____分钟，问题：____________________
- [ ] 第2次：____月____日，耗时____分钟，问题：____________________
- [ ] 第3次：____月____日，耗时____分钟，问题：____________________
- [ ] 目标：3次内稳定5分钟手搓通过，0语法错误

---

**最后提醒**：先写排序法保底线，再讲计数法展深度，复杂度分析要脱口而出！