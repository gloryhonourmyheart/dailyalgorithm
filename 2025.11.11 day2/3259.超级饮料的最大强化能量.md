# 3259. 超级饮料的最大强化能量 - Todo List

来自未来的体育科学家给你两个整数数组 energyDrinkA 和 energyDrinkB，数组长度都等于 n。这两个数组分别代表 A、B 两种不同能量饮料每小时所能提供的强化能量。

你需要每小时饮用一种能量饮料来 最大化 你的总强化能量。然而，如果从一种能量饮料切换到另一种，你需要等待一小时来梳理身体的能量体系（在那个小时里你将不会获得任何强化能量）。

返回在接下来的 n 小时内你能获得的 最大 总强化能量。

注意 你可以选择从饮用任意一种能量饮料开始。



## 1. 理解题目
- [ ] 确认题目要求：最大化总强化能量，注意切换饮料需要等待一小时。
- [ ] 理解输入和输出格式：
  - 输入：两个数组 `energyDrinkA` 和 `energyDrinkB`，长度为 `n`。
  - 输出：一个整数，表示最大总强化能量。

## 2. 分析问题
- [ ] 明确问题的难点：如何在切换饮料时处理等待一小时的限制。
- [ ] 确认动态规划是解决此问题的合适方法。

## 3. 动态规划解法
### 3.1 定义状态
- [ ] 定义 `dp[i][0]`：第 `i` 小时结束时，最后饮用A的最大总能量。
- [ ] 定义 `dp[i][1]`：第 `i` 小时结束时，最后饮用B的最大总能量。

### 3.2 状态转移方程
- [ ] 理解状态转移逻辑：
  - 如果第 `i` 小时饮用A：
    - 继续饮用A：`dp[i-1][0] + energyDrinkA[i]`
    - 从B切换到A：`dp[i-2][1] + energyDrinkA[i]`
  - 如果第 `i` 小时饮用B：
    - 继续饮用B：`dp[i-1][1] + energyDrinkB[i]`
    - 从A切换到B：`dp[i-2][0] + energyDrinkB[i]`

### 3.3 初始化状态
- [ ] 初始化第0小时的状态：
  - `dp[0][0] = energyDrinkA[0]`
  - `dp[0][1] = energyDrinkB[0]`
- [ ] 如果 `n >= 2`，初始化第1小时的状态：
  - `dp[1][0] = dp[0][0] + energyDrinkA[1]`
  - `dp[1][1] = dp[0][1] + energyDrinkB[1]`

### 3.4 状态转移实现
- [ ] 从第2小时开始，逐步更新 `dp[i][0]` 和 `dp[i][1]`：
  ```javascript
  for (let i = 2; i < n; i++) {
      dp[i][0] = Math.max(dp[i-1][0] + energyDrinkA[i], dp[i-2][1] + energyDrinkA[i]);
      dp[i][1] = Math.max(dp[i-1][1] + energyDrinkB[i], dp[i-2][0] + energyDrinkB[i]);
  }
  ```

### 3.5 返回结果
- [ ] 返回最终的最大总能量：
  ```javascript
  return Math.max(dp[n-1][0], dp[n-1][1]);
  ```

## 4. 代码实现
### 4.1 完整代码
- [ ] 实现完整的动态规划代码：
  ```javascript
  function maxEnergy(energyDrinkA, energyDrinkB) {
      const n = energyDrinkA.length;
      const dp = Array.from({ length: n }, () => [0, 0]);

      dp[0][0] = energyDrinkA[0];
      dp[0][1] = energyDrinkB[0];

      if (n >= 2) {
          dp[1][0] = dp[0][0] + energyDrinkA[1];
          dp[1][1] = dp[0][1] + energyDrinkB[1];
      }

      for (let i = 2; i < n; i++) {
          dp[i][0] = Math.max(dp[i-1][0] + energyDrinkA[i], dp[i-2][1] + energyDrinkA[i]);
          dp[i][1] = Math.max(dp[i-1][1] + energyDrinkB[i], dp[i-2][0] + energyDrinkB[i]);
      }

      return Math.max(dp[n-1][0], dp[n-1][1]);
  }
  ```
  带注释

    ```javascript
    function maxEnergy(energyDrinkA, energyDrinkB) {
    const n = energyDrinkA.length; // 获取数组长度
    const dp = Array.from({ length: n }, () => [0, 0]); // 初始化二维数组 dp

    // 第0小时的初始状态
    dp[0][0] = energyDrinkA[0]; // 第0小时饮用 A
    dp[0][1] = energyDrinkB[0]; // 第0小时饮用 B

    // 如果有第1小时，更新第1小时的状态
    if (n >= 2) {
        dp[1][0] = dp[0][0] + energyDrinkA[1]; // 第1小时继续饮用 A
        dp[1][1] = dp[0][1] + energyDrinkB[1]; // 第1小时继续饮用 B
    }

    // 从第2小时开始，更新每小时的状态
    for (let i = 2; i < n; i++) {
        dp[i][0] = Math.max(dp[i-1][0] + energyDrinkA[i], dp[i-2][1] + energyDrinkA[i]);
        dp[i][1] = Math.max(dp[i-1][1] + energyDrinkB[i], dp[i-2][0] + energyDrinkB[i]);
    }

    // 最后返回最大总能量：最后饮用 A 或 B 的最大值
    return Math.max(dp[n-1][0], dp[n-1][1]);
  }
  ```
  
官方题解
  ```javascript  

  var maxEnergyBoost = function(energyDrinkA, energyDrinkB) {
  const n = energyDrinkA.length;
  const d = Array.from({ length: n + 1 }, () => [0, 0]);
  for (let i = 1; i <= n; i++) {
      d[i][0] = d[i - 1][0] + energyDrinkA[i - 1];
      d[i][1] = d[i - 1][1] + energyDrinkB[i - 1];
      if (i >= 2) {
          d[i][0] = Math.max(d[i][0], d[i - 2][1] + energyDrinkA[i - 1]);
          d[i][1] = Math.max(d[i][1], d[i - 2][0] + energyDrinkB[i - 1]);
      }
  }
  return Math.max(d[n][0], d[n][1]);
  };

  ```

## 5. 复习和总结
- [ ] 复习动态规划的基本概念和状态转移的逻辑。
- [ ] 总结如何从问题描述中提取动态规划的状态和转移方程。
- [ ] 确保能够独立手写代码并解释每一步的逻辑。

## 6. 面试准备
- [ ] 能够清晰地解释为什么选择动态规划来解决这个问题。
- [ ] 能够在白板上手写代码并逐步解释逻辑。
- [ ] 准备回答可能的扩展问题，例如：
  - 如果可以切换饮料的次数有限制怎么办？
  - 如果等待时间不是一小时而是两小时怎么办？


