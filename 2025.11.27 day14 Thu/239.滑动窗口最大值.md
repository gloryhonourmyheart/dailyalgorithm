# 239.滑动窗口最大值
提示
给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

 

示例 1：

输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
示例 2：

输入：nums = [1], k = 1
输出：[1]


提示：

1 <= nums.length <= 105
-104 <= nums[i] <= 104
1 <= k <= nums.length



# 239. 滑动窗口最大值 - 面试手搓指南

## 一、面试开场话术

**"这道题最优解是使用单调递减双端队列，时间复杂度O(n)，空间复杂度O(k)。核心思想是维护一个候选人队列，让每个元素最多入队和出队一次，避免重复比较。"**

---

## 二、核心思路（四步口诀）

想象维护一个**候选人走廊**（deque），每个新元素 `nums[i]` 到来时做四件事：

1. **清队首**：检查队首老人是否已滑出窗口
2. **清队尾**：新人把比自己弱的全部踢掉
3. **新人入队**：当前索引入队
4. **输出结果**：窗口形成后，队首就是最大值

---

## 三、手搓代码（逐行注释版）

```javascript
var maxSlidingWindow = function(nums, k) {
    const n = nums.length;          // 数组长度
    const deque = [];               // 候选人队列（存索引）
    const result = [];              // 最终答案

    for (let i = 0; i < n; i++) {
        // 步骤1：清队首 - 老人是否已滑出窗口？
        // 窗口起始位置 = i - k + 1
        if (deque.length > 0 && deque[0] < i - k + 1) {
            deque.shift();          // 从队首移除过期索引
        }

        // 步骤2：清队尾 - 新人能否吊打你？
        // 从队尾开始，移除所有比新人弱的
        while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {
            deque.pop();            // 从队尾移除弱者
        }

        // 步骤3：新人入队 - 获得候选资格
        deque.push(i);              // 存储索引而非值

        // 步骤4：输出答案 - 窗口已形成？
        // i ≥ k-1 表示第一次窗口已满
        if (i >= k - 1) {
            result.push(nums[deque[0]]); // 队首就是当前窗口最大值
        }
    }

    return result;
};
```

## 暴力解法（O(n*k)）

### 思路
对每个窗口，都遍历其中的 k 个元素找到最大值。

### 步骤
1. 结果数组长度为 `n - k + 1`
2. 外层循环：从 `i = 0` 到 `n - k`
3. 内层循环：从 `j = i` 到 `i + k - 1`，找最大值
4. 将最大值加入结果

### 代码（带注释）

```javascript
// 暴力解法：每个窗口都遍历k个元素找最大值
var maxSlidingWindow = function(nums, k) {
    const n = nums.length;           // 获取数组长度
    const result = [];               // 存储最终结果
    // 遍历所有可能的窗口起始位置，最后一个窗口起始位置是 n-k
    for (let i = 0; i <= n - k; i++) {
        let max = nums[i];           // 假设窗口第一个元素是当前最大值
        // 在当前窗口内遍历，找到真正的最大值
        for (let j = i; j < i + k; j++) {
            if (nums[j] > max) {     // 如果找到更大的值
                max = nums[j];       // 更新最大值
            }
        }
        result.push(max);            // 将当前窗口最大值加入结果
    }
    return result;                   // 返回所有窗口的最大值数组
};
```

### 复杂度分析
- **时间复杂度**：O(n*k)，每个窗口都要遍历 k 个元素
- **空间复杂度**：O(1)，不考虑结果数组的空间

**缺点**：当 n=10^5, k=10^5 时，会超时！

---

## 最优解法 - 单调队列（O(n)）

### 核心思想
维护一个**单调递减的双端队列**，队列前端始终是当前窗口的最大值。

**为什么用双端队列？**
- 队首：存放当前窗口的最大值
- 队尾：用于移除比新元素小的值，保持递减性
- 两端都能高效操作

### 代码（逐行注释）

```javascript
// 最优解法：使用单调递减双端队列
var maxSlidingWindow = function(nums, k) {
    const n = nums.length;           // 获取数组长度
    const deque = [];                // 双端队列，存储数组下标（而非值）
    const result = [];               // 存储最终结果
    
    // 遍历数组中的每个元素
    for (let i = 0; i < n; i++) {
        // 1. 清理队首：如果队首元素已经滑出窗口，将其移除
        // 条件：队首元素的下标 < 当前窗口的起始位置(i - k + 1)
        if (deque.length > 0 && deque[0] < i - k + 1) {
            deque.shift();           // 从队首移除过期元素
        }
        
        // 2. 清理队尾：保持队列单调递减
        // 从队尾开始，移除所有值小于等于当前元素的元素
        // 因为这些元素在当前元素存在的情况下，再也不可能是最大值
        while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {
            deque.pop();             // 从队尾移除较小的元素
        }
        
        // 3. 将当前元素下标加入队列
        deque.push(i);               // 当前元素可能成为后续窗口的最大值
        
        // 4. 当窗口完全形成后（i >= k - 1），开始记录结果
        if (i >= k - 1) {
            // 队首元素对应的值就是当前窗口的最大值
            result.push(nums[deque[0]]);
        }
    }
    
    return result;                   // 返回所有窗口的最大值数组
};
```

### 代码（逐行解读）

```javascript
var maxSlidingWindow = function(nums, k) {
    // 初始化基本参数
    const n = nums.length;           // 数组长度，用于循环
    const deque = [];                // 核心数据结构：单调递减双端队列
    const result = [];               // 最终返回的结果数组
    
    // 主循环，处理每个元素
    for (let i = 0; i < n; i++) {
        // 步骤1：检查队首是否需要移除
        // deque[0]是窗口中最大值的索引
        // 如果它小于当前窗口起始位置i-k+1，说明已滑出窗口
        if (deque.length > 0 && deque[0] < i - k + 1) {
            deque.shift();           // 从队首移除，shift()操作时间复杂度O(1)
        }
        
        // 步骤2：维护队列单调递减性质
        // 当新元素nums[i]大于等于队尾元素时，队尾元素永无出头之日
        // 因为新元素更晚加入，会在窗口中存在更久
        while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {
            deque.pop();             // 从队尾移除这些"永无机会"的元素
        }
        
        // 步骤3：当前元素入队
        // 无论当前元素大小，都可能成为后续窗口的最大值
        deque.push(i);               // 存储索引而非值，方便判断窗口位置
        
        // 步骤4：窗口形成后记录结果
        // 前k-1次循环(i=0到k-2)窗口未完全形成
        // 从i=k-1开始，窗口已形成，可以输出结果
        if (i >= k - 1) {
            result.push(nums[deque[0]]); // deque[0]始终是当前窗口最大值索引
        }
    }
    
    return result;                   // 返回最终结果
};
```



##  无注释代码

```javascript
var maxSlidingWindow = function(nums, k) {
    const n = nums.length;
    const deque = [];
    const result = [];
    
    for (let i = 0; i < n; i++) {
        if (deque.length > 0 && deque[0] < i - k + 1) {
            deque.shift();
        }
        
        while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {
            deque.pop();
        }
        
        deque.push(i);
        
        if (i >= k - 1) {
            result.push(nums[deque[0]]);
        }
    }
    
    return result;
};
```

---

## 四、代码关键点解析（面试必答）

### **1. 为什么用队列存索引而不是值？**
- 既要比较**值的大小**（`nums[i]`），也要判断**位置是否过期**（`deque[0] < i-k+1`）
- 只存值无法判断元素是否还在窗口内

### **2. 为什么 `deque[0] < i - k + 1` 表示过期？**
```javascript
// 举例：i=3, k=3
// 窗口起始位置 = 3 - 3 + 1 = 1
// 若 deque[0] = 0，说明0号元素已不在窗口[1,2,3]内
// 所以 0 < 1 成立，必须移除
```

### **3. 为什么用 `while` 而不是 `if` 清队尾？**
- 因为新人可能**连续淘汰多个弱者**
- 示例：`nums = [1, 2, 3]`，当3来到时，需要**连续pop 1和2**

### **4. 为什么时间复杂度是 O(n)？**
- **每个元素最多入队一次、出队一次**
- 所有 `shift + pop` 操作加起来 ≤ n 次
- 均摊到每次循环是 O(1)

---

## 五、复杂度分析（面试必背）

| 项目           | 复杂度   | 说明                           |
| -------------- | -------- | ------------------------------ |
| **时间复杂度** | **O(n)** | 每个元素最多入队、出队各一次   |
| **空间复杂度** | **O(k)** | deque最多存k个元素（窗口大小） |
| **最坏情况**   | O(n)     | 数组递减时，deque始终为k个元素 |

---

## 六、高频易错点（面试陷阱）

### ❌ **错误1：向deque里push值**
```javascript
// 错误
deque.push(nums[i]);  // 类型混乱，后续比较出错

// 正确
deque.push(i);  // 始终存索引
```

### ❌ **错误2：忘记检查deque为空**
```javascript
// 错误
if (deque[0] < i - k + 1)  // deque为空时访问deque[0]报错

// 正确
if (deque.length > 0 && deque[0] < i - k + 1)
```

### ❌ **错误3：push到result误写成push到deque**
```javascript
// 错误
deque.push(nums[deque[0]]);  // 导致result为空

// 正确
result.push(nums[deque[0]]);
```

---

## 七、面试记忆口诀

**"清队首，清队尾，新人入队，出结果"**

**对应代码：**
```
shift()  ← 清队首
pop()    ← 清队尾
push(i)  ← 新人入队
push(...)← 出结果
```

---

## 八、快速验证（面试时自测）

用一个**3个元素的小数组**快速走一遍：

```javascript
nums = [1, 3, 2], k = 3

i=0: deque=[0], result=[]
i=1: deque=[1], result=[]      // 3淘汰1
i=2: deque=[1,2], result=[3]   // 2入队，输出队首3

✓ 结果正确：[3]
```

---

## 九、面试时画图辅助

在白板上画这个结构：

```
数组:    [a, b, c, d, e]
          ↑↑↑
窗口k=3: [窗口] → 最大值?

deque: [索引x, 索引y]  // 值: val_x > val_y
        ↑
      队首（当前最大值）
```

**核心原则：** deque里永远是**值递减**的"未来有机会"的候选者。

---

## 十、总结（面试收尾话术）

**"这个算法通过维护单调递减队列，让每个元素最多进出队列一次，将暴力法的O(nk)优化到O(n)。核心是通过索引判断过期，通过值判断强弱，双端操作保证效率。"**

---

**现在你可以自信地在面试中写出这道题了！**

