# 239.滑动窗口最大值
提示
给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回 滑动窗口中的最大值 。

 

示例 1：

输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
示例 2：

输入：nums = [1], k = 1
输出：[1]


提示：

1 <= nums.length <= 105
-104 <= nums[i] <= 104
1 <= k <= nums.length



# 239. 滑动窗口最大值 - 面试手搓指南

## 一、面试开场话术

**"这道题最优解是使用单调递减双端队列，时间复杂度O(n)，空间复杂度O(k)。核心思想是维护一个候选人队列，让每个元素最多入队和出队一次，避免重复比较。"**

---

## 二、核心思路（四步口诀）

想象维护一个**候选人走廊**（deque），每个新元素 `nums[i]` 到来时做四件事：

1. **清队首**：检查队首老人是否已滑出窗口
2. **清队尾**：新人把比自己弱的全部踢掉
3. **新人入队**：当前索引入队
4. **输出结果**：窗口形成后，队首就是最大值

---

## 三、手搓代码（逐行注释版）

```javascript
var maxSlidingWindow = function(nums, k) {
    const n = nums.length;          // 数组长度
    const deque = [];               // 候选人队列（存索引）
    const result = [];              // 最终答案

    for (let i = 0; i < n; i++) {
        // 步骤1：清队首 - 老人是否已滑出窗口？
        // 窗口起始位置 = i - k + 1
        if (deque.length > 0 && deque[0] < i - k + 1) {
            deque.shift();          // 从队首移除过期索引
        }

        // 步骤2：清队尾 - 新人能否吊打你？
        // 从队尾开始，移除所有比新人弱的
        while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {
            deque.pop();            // 从队尾移除弱者
        }

        // 步骤3：新人入队 - 获得候选资格
        deque.push(i);              // 存储索引而非值

        // 步骤4：输出答案 - 窗口已形成？
        // i ≥ k-1 表示第一次窗口已满
        if (i >= k - 1) {
            result.push(nums[deque[0]]); // 队首就是当前窗口最大值
        }
    }

    return result;
};
```

---

## 四、代码关键点解析（面试必答）

### **1. 为什么用队列存索引而不是值？**
- 既要比较**值的大小**（`nums[i]`），也要判断**位置是否过期**（`deque[0] < i-k+1`）
- 只存值无法判断元素是否还在窗口内

### **2. 为什么 `deque[0] < i - k + 1` 表示过期？**
```javascript
// 举例：i=3, k=3
// 窗口起始位置 = 3 - 3 + 1 = 1
// 若 deque[0] = 0，说明0号元素已不在窗口[1,2,3]内
// 所以 0 < 1 成立，必须移除
```

### **3. 为什么用 `while` 而不是 `if` 清队尾？**
- 因为新人可能**连续淘汰多个弱者**
- 示例：`nums = [1, 2, 3]`，当3来到时，需要**连续pop 1和2**

### **4. 为什么时间复杂度是 O(n)？**
- **每个元素最多入队一次、出队一次**
- 所有 `shift + pop` 操作加起来 ≤ n 次
- 均摊到每次循环是 O(1)

---

## 五、复杂度分析（面试必背）

| 项目           | 复杂度   | 说明                           |
| -------------- | -------- | ------------------------------ |
| **时间复杂度** | **O(n)** | 每个元素最多入队、出队各一次   |
| **空间复杂度** | **O(k)** | deque最多存k个元素（窗口大小） |
| **最坏情况**   | O(n)     | 数组递减时，deque始终为k个元素 |

---

## 六、高频易错点（面试陷阱）

### ❌ **错误1：向deque里push值**
```javascript
// 错误
deque.push(nums[i]);  // 类型混乱，后续比较出错

// 正确
deque.push(i);  // 始终存索引
```

### ❌ **错误2：忘记检查deque为空**
```javascript
// 错误
if (deque[0] < i - k + 1)  // deque为空时访问deque[0]报错

// 正确
if (deque.length > 0 && deque[0] < i - k + 1)
```

### ❌ **错误3：push到result误写成push到deque**
```javascript
// 错误
deque.push(nums[deque[0]]);  // 导致result为空

// 正确
result.push(nums[deque[0]]);
```

---

## 七、面试记忆口诀

**"清队首，清队尾，新人入队，出结果"**

**对应代码：**
```
shift()  ← 清队首
pop()    ← 清队尾
push(i)  ← 新人入队
push(...)← 出结果
```

---

## 八、快速验证（面试时自测）

用一个**3个元素的小数组**快速走一遍：

```javascript
nums = [1, 3, 2], k = 3

i=0: deque=[0], result=[]
i=1: deque=[1], result=[]      // 3淘汰1
i=2: deque=[1,2], result=[3]   // 2入队，输出队首3

✓ 结果正确：[3]
```

---

## 九、面试时画图辅助

在白板上画这个结构：

```
数组:    [a, b, c, d, e]
          ↑↑↑
窗口k=3: [窗口] → 最大值?

deque: [索引x, 索引y]  // 值: val_x > val_y
        ↑
      队首（当前最大值）
```

**核心原则：** deque里永远是**值递减**的"未来有机会"的候选者。

---

## 十、总结（面试收尾话术）

**"这个算法通过维护单调递减队列，让每个元素最多进出队列一次，将暴力法的O(nk)优化到O(n)。核心是通过索引判断过期，通过值判断强弱，双端操作保证效率。"**

---

**现在你可以自信地在面试中写出这道题了！**

