# [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

提示



给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

 

**示例 1:**

```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
```

**示例 2:**

```
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
```

 

**提示：**

- `1 <= nums.length <= 105`
- `-231 <= nums[i] <= 231 - 1`
- `0 <= k <= 105`

 

**进阶：**

- 尽可能想出更多的解决方案，至少有 **三种** 不同的方法可以解决这个问题。

- 你可以使用空间复杂度为 `O(1)` 的 **原地** 算法解决这个问题吗？

  

# 189. 轮转数组 - 面试手搓指南

## 一、题目速览

**核心操作**：将数组 `nums` 向右旋转 `k` 个位置，**原地修改**。

**关键约束**：
- `1 <= nums.length <= 10⁵`
- `k` 可能 **远大于** 数组长度
- 要求 **空间复杂度 O(1)**

---

## 二、面试时手搓代码（最优解）

### 三次翻转法 - 标准模板

```javascript
var rotate = function(nums, k) {
    const n = nums.length;
    k %= n; // 关键：处理 k > n 的情况，避免越界
    
    // 1. 翻转全部
    reverse(0, n - 1);
    // 2. 翻转前 k 个
    reverse(0, k - 1);
    // 3. 翻转剩余
    reverse(k, n - 1);
    
    // 翻转函数
    function reverse(start, end) {
        while (start < end) {
            [nums[start], nums[end]] = [nums[end], nums[start]];
            start++;
            end--;
        }
    }
};
```


    
```javascript
var rotate = function(nums, k) {
    const n = nums.length;
    if (n === 0) return;      // ✅ 边界检查
    
    k %= n;                   // 处理 k > n
    
    const reverse = (start, end) => {  // ✅ 箭头函数，现代JS风格
        while (start < end) {
            [nums[start], nums[end]] = [nums[end], nums[start]];
            start++;
            end--;
        }
    };
    
    reverse(0, n - 1);
    reverse(0, k - 1);
    reverse(k, n - 1);
};
```


**面试敲代码顺序**：

1. 先写主体函数框架
2. 立刻写 `k %= n`（向面试官展示你考虑了边界）
3. 写三次 `reverse` 调用（体现核心思路）
4. 最后补 `reverse` 函数实现（细节后置）

---

## 三、代码逐行注释（默写版）

```javascript
var rotate = function(nums, k) {
    const n = nums.length;    // 获取数组长度
    k %= n;                   // 【易错点】k 可能大于 n，取模后得到有效旋转次数
    
    // 三次翻转实现旋转
    reverse(0, n - 1);        // ① 翻转全部：把数组整体倒序
    reverse(0, k - 1);        // ② 翻转前 k 个：恢复前段顺序
    reverse(k, n - 1);        // ③ 翻转后 n-k 个：恢复后段顺序
    
    // 翻转函数（双指针交换）
    function reverse(start, end) {
        while (start < end) {                     // 双指针向中间靠拢
            [nums[start], nums[end]] = [nums[end], nums[start]]; // 交换
            start++;                                // 左指针右移
            end--;                                  // 右指针左移
        }
    }
};
```

```javascript
var rotate = function(nums, k) {
    const n = nums.length;
    k %= n;
    let count = 0;
    
    for (let start = 0; count < n; start++) {
        let current = start;
        let prev = nums[start];
        
        do {
            let next = (current + k) % n;
            [nums[next], prev] = [prev, nums[next]]; // 交换
            current = next;
            count++;
        } while (current !== start);
    }
};
```

---

## 四、算法思路（面试话术）

**对面试官说**：
> "这道题的关键是发现旋转的周期性：旋转 n 次等于没转，所以实际只需旋转 `k % n` 次。
>
> 我的思路是**三次翻转法**：
> 1. 先把整个数组翻转，这样后 k 个元素就到了前面，但顺序是反的
> 2. 再把前 k 个元素翻转，纠正它们的顺序
> 3. 最后把剩下的元素翻转，纠正它们的顺序
>
> 这样每个元素只被移动了常数次，时间 O(n)，空间 O(1)。"

---

## 五、复杂度分析（必背）

| 维度     | 复杂度   | 说明                                             |
| -------- | -------- | ------------------------------------------------ |
| **时间** | **O(n)** | 每个元素被翻转 2 次，常数因子为 2                |
| **空间** | **O(1)** | 原地修改，只使用常数级额外空间（指针和临时变量） |

---

## 六、核心要点与易错点

### ✨ 必须强调的三件事

1. **`k %= n` 不可或缺**
   - 防止 `k > n` 时索引越界
   - 消除无效旋转（转 n 圈=不转）
   - **面试时主动说出这点会加分**

2. **三次翻转的顺序不能错**
   - 必须：整体 → 前 k → 后 n-k
   - 顺序乱了结果全错

3. **reverse 函数的双指针写法**
   - `while (start < end)` 确保不重复交换
   - `start++` 和 `end--` 必须同时执行
   - 可以用解构赋值 `[a,b]=[b,a]` 或临时变量

### ⚠️ 常见手滑错误

```javascript
// ❌ 错误：忘记 k %= n
reverse(0, k - 1);  // 当 k > n 时，k-1 索引越界！

// ❌ 错误：reverse 循环条件写错
while (start <= end) { ... }  // 会导致中间元素被交换两次

// ❌ 错误：忘记移动指针
while (start < end) {
    [nums[start], nums[end]] = [nums[end], nums[start]];
    // 没写 start++ 和 end-- → 死循环！
}
```

---

## 七、面试追问准备

### Q1: 为什么这样翻转能得到正确结果？
**答**：数学上的位置映射。设原索引为 `i`，旋转后索引为 `(i+k)%n`。三次翻转恰好实现了这个映射。

### Q2: 还有别的方法吗？
**答**：
- **额外数组**：开一个新数组，直接赋值 `ans[(i+k)%n] = nums[i]`，空间 O(n)
- **环状替换**：从每个元素出发，通过公式 `(i+k)%n` 找到目标位置，形成置换环。但代码较复杂，且有边界情况（k 和 n 不互质时需多个环）

### Q3: 如果要求不能修改原数组，返回新数组呢？
**答**：那就用额外数组法，空间 O(n) 是允许的：
```javascript
const rotate = (nums, k) => {
    const n = nums.length;
    k %= n;
    const ans = new Array(n);
    for (let i = 0; i < n; i++) {
        ans[(i + k) % n] = nums[i];
    }
    return ans;
};
```

---

## 八、完整版（可直接默写）

```javascript
/**
 * 旋转数组 - 三次翻转法
 * 时间 O(n)，空间 O(1)
 */
var rotate = function(nums, k) {
    const n = nums.length;
    if (n === 0) return;          // 边界检查（可选，但体现严谨）
    
    k %= n;                       // ✅ 核心：处理 k > n
    
    // 三次翻转
    reverse(0, n - 1);
    reverse(0, k - 1);
    reverse(k, n - 1);
    
    // 翻转函数
    function reverse(start, end) {
        while (start < end) {
            // ES6 解构赋值交换
            [nums[start], nums[end]] = [nums[end], nums[start]];
            start++;
            end--;
        }
    }
};
```

**面试结束语**："代码完成，时间复杂度 O(n)，空间复杂度 O(1)，满足题目要求。"