# 🎯 面试八股文：JS 连续 bind 的 this 指向问题

---

## **一、面试官常见提问方式**

### **方式 1：直接概念题**
> "连续多次调用 bind，this 最终指向什么？为什么？"

### **方式 2：代码输出题**
> "请说出下面代码的输出并解释原因"
> ```js
> function foo() { console.log(this.a); }
> const obj1 = { a: 1 }, obj2 = { a: 2 }, obj3 = { a: 3 };
> const bound = foo.bind(obj1).bind(obj2).bind(obj3);
> bound(); // 输出？
> ```

### **方式 3：手写实现题**
> "请手写一个简化版的 bind 函数，并解释为什么多次 bind 无效"

### **方式 4：对比辨析题**
> "bind、call、apply 的区别是什么？箭头函数的 this 和 bind 绑定的 this 谁优先级更高？"

---

## **二、标准答案模板（必须背熟）**

### **核心结论（先声夺人）**
**多次 bind 只认第一次，后续 bind 无效。this 永远指向第一个非 null/undefined 的绑定对象。**

### **技术原理（展示深度）**
1. **bind 的不可逆性**：`bind()` 返回的是一个**新函数**，该函数内部通过闭包永久保存了初次绑定的 this 上下文，后续再对返回函数调用 bind 无法修改已闭包的 this 值
2. **null/undefined 的特殊处理**：若 bind 的参数是 null 或 undefined，this 会指向全局对象（浏览器为 `window`，Node 为 `global`），这是 JS 的"兜底机制"
3. **绑定优先级**：new > 显式绑定(call/apply/bind) > 隐式绑定(obj.fn()) > 默认绑定

### **代码分析（逐行拆解）**
```js
// 定义函数
function foo() { console.log(this.name); }

// 创建对象
const obj1 = { name: 'A' };
const obj2 = { name: 'B' };

// 连续绑定
const bound = foo.bind(obj1)  // 返回新函数 f1: this = obj1 (闭包锁定)
                 .bind(obj2)  // 对 f1 再绑定，返回 f2，但 f1 的 this 已锁定，无效
                 .bind(null); // 对 f2 再绑定，返回 f3，依然无效

bound(); // 输出 "A"
```

**执行流程：**
1. `foo.bind(obj1)` → 生成 **f1**，内部 `[[BoundThis]] = obj1`
2. `f1.bind(obj2)` → 生成 **f2**，尝试修改 `[[BoundThis]]` 失败（只读）
3. `f2.bind(null)` → 生成 **f3**，尝试修改 `[[BoundThis]]` 失败
4. `bound()` → `this` 取 `[[BoundThis]]` 的值 **obj1**

---

## **三、回答要点（结构化表达）**

### **推荐话术结构：**

**1. 结论先行（让面试官听到重点）**
> "这道题考察的是 bind 的不可逆性。结论是：**只认第一次绑定**，后续的 bind 调用都无法改变 this 指向。"

**2. 原理剖析（展示理解深度）**
> "因为 bind 返回的是一个**包装函数**，这个包装函数通过闭包保存了最初的 this。后续再对这个包装函数调用 bind，只是在外层再包一层，但核心的 this 已经固化在闭包里了。"

**3. 分步图解（适合白板面试）"
```plaintext
foo函数
  ↓ bind(obj1)
包装函数1: [[BoundThis]] = obj1
  ↓ bind(obj2)
包装函数2: [[BoundThis]] = obj1 (无效修改)
  ↓ bind(null)
包装函数3: [[BoundThis]] = obj1 (无效修改)

最终 this = obj1
```

**4. 边界情况补充（体现严谨性）**
> "需要注意的是，如果第一次 bind 的是 null 或 undefined，this 会指向全局对象，这可能导致全局污染。ES5+ 环境中，如果是严格模式，则 this 为 undefined。"

---

## **四、加分项（拉开差距的关键）**

### **加分 1：提及规范细节 **
> "根据 ECMAScript 规范，bind 返回的函数有一个内部槽位 `[[BoundThis]]`，这个值在函数创建时就确定了，** 不可变更 **。后续调用 bind 只是对这个已绑定函数进行再包装，但无法修改其内部的 `[[BoundThis]]`。"

### ** 加分 2：主动对比 related concepts **
> "相比之下，call/apply 是** 一次性绑定 **，直接执行；而 bind 是** 永久性绑定 **，返回新函数。箭头函数则完全无视 bind，它的 this 由词法作用域决定，优先级高于 bind。"

### ** 加分 3：实际应用场景 **
> "在实际开发中，这个特性常用于：
> - 事件处理：`this.btn.onclick = this.handleClick.bind(this)` 确保回调里 this 指向组件实例
> - 定时器：`setTimeout(this.update.bind(this), 1000)` 避免 this 丢失
> - 防止误绑定：bind 一次后不怕被再修改，保证上下文安全"

### ** 加分 4：手写简化版 bind **
```js
// 展示核心思路
Function.prototype.myBind = function(context, ...args) {
  const fn = this; // 原函数
  return function(...innerArgs) {
    return fn.apply(context, args.concat(innerArgs)); // this 已锁定
  };
};
// 解释：返回的函数里永久保存了 context，无法被二次修改
```

---

## **五、避坑指南（高频错误）**

| 错误类型                 | 错误示例                         | 后果                        | 正确做法                                  |
| ------------------------ | -------------------------------- | --------------------------- | ----------------------------------------- |
| ** 重复绑定期望生效 **   | `fn.bind(a).bind(b)` 期望 this=b | this 仍是 a                 | 只 bind 一次，或用变量保存                |
| ** null/undefined 绑定** | `fn.bind(null)`                  | this → window/global        | 用 `Object.create(null)` 或 `{}` 作为占位 |
| **箭头函数误用 bind**    | `(() => {}).bind(obj)`           | 无效，this 仍继承外层       | 箭头函数不需要 bind                       |
| **忘记 bind 返回新函数** | `fn.bind(obj); fn()`             | this 未改变，原函数未受影响 | `const newFn = fn.bind(obj); newFn()`     |

---

## **六、追问问题准备（面试官可能深挖）**

### **追问 1：如何强制改变已 bind 函数的 this？**
**答**：**无法强制改变**。唯一办法是重新绑定原函数。但可以通过 **柯里化** 实现部分参数修改：
```js
const f1 = foo.bind(obj1);
const f2 = f1.bind(null, arg1); // 只能加参数，不能改 this
```

### **追问 2：箭头函数的 this 和 bind 谁优先？**
**答**：**箭头函数优先**。箭头函数没有自己的 this，它会** 无视 **任何 bind/call/apply，永远指向定义时的外层作用域。

### **追问 3：bind 的原理是什么？如何实现一个 polyfill？**
**答**：核心是 **闭包 + 偏函数 + 构造器判断**。需处理：
- this 绑定（通过闭包保存）
- 参数合并（柯里化）
- new 调用判断（bind 后的函数还能被 new）

### **追问 4：严格模式下 bind(null) 表现有何不同？**
**答**：严格模式下，`this` 就是 `null`，不会 fallback 到全局对象。访问 this.name 会报错：`Cannot read property 'name' of null`。

---

## **七、一句话背诵版（面试完总结）**

> "Bind 一次定终身，返回新函数闭包锁死 this，后续再 bind 白费劲。记住优先级 new > bind > 隐式 > 默认，箭头函数无视 bind，null 绑定要小心全局污染。"

---

**使用建议**：先背熟"标准答案模板"，理解"回答要点"结构，面试时主动提及 1-2 个"加分项"，最后对"避坑指南"心中有数。遇到追问不要慌，按准备的内容逐一拆解即可。