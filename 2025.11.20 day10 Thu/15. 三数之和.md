# [15. 三数之和](https://leetcode.cn/problems/3sum/)

提示



给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

 

 

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**示例 2：**

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

**示例 3：**

```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```

 

**提示：**

- `3 <= nums.length <= 3000`
- `-105 <= nums[i] <= 105`



# 三数之和 - 面试速成版

## 📋 面试现场手搓代码模板

### 题目描述
给定整数数组 `nums`，返回所有和为 0 且不重复的三元组 `[nums[i], nums[j], nums[k]]`。

### 核心框架（先写这5步）
1. **排序**：升序排列，为双指针铺路
2. **固定数**：遍历到 `n-2`，作为第一个元素
3. **剪枝**：`nums[i] > 0` 直接 `break`
4. **去重**：跳过重复的固定数 `nums[i]`
5. **双指针**：`left` 和 `right` 相向扫描

### ✅ 完整代码（可直接默写）
```javascript
var threeSum = function(nums) {
    const res = [];
    const n = nums.length;
    if (n < 3) return res; // 边界检查
    
    nums.sort((a, b) => a - b); // 1. 升序排序
    
    for (let i = 0; i < n - 2; i++) { // 2. 固定第一个数
        if (nums[i] > 0) break; // 剪枝：最小数都>0，后面无解
        
        if (i > 0 && nums[i] === nums[i - 1]) continue; // 3. 固定数去重
        
        let left = i + 1, right = n - 1; // 4. 双指针初始化
        
        while (left < right) { // 5. 相向扫描
            const sum = nums[i] + nums[left] + nums[right];
            
            if (sum === 0) {
                res.push([nums[i], nums[left], nums[right]]);
                
                // 6. 找到后去重：跳过重复值
                while (left < right && nums[left] === nums[left + 1]) left++;
                while (left < right && nums[right] === nums[right - 1]) right--;
                
                left++; // 7. 移动到下一个不同数
                right--;
            } else if (sum < 0) {
                left++; // 和太小，左指针右移
            } else {
                right--; // 和太大，右指针左移
            }
        }
    }
    return res;
};
```

---

## 🎯 面试高频考点（必背）

### 考点1：三重去重机制
| 去重位置   | 代码                                                         | 作用                       | 易错点                   |
| ---------- | ------------------------------------------------------------ | -------------------------- | ------------------------ |
| **固定数** | `if (i > 0 && nums[i] === nums[i - 1]) continue`             | 跨轮次去重，避免重复三元组 | 必须用 `i-1` 而非 `i+1`  |
| **左指针** | `while (left < right && nums[left] === nums[left + 1]) left++` | 本轮内去重，跳过重复左值   | 必须在 `push` **后**执行 |
| **右指针** | `while (left < right && nums[right] === nums[right - 1]) right--` | 本轮内去重，跳过重复右值   | 必须用 `right-1` 比较    |

### 考点2：为什么 `push` 后才去重？
```javascript
// 错误示范：先跳过后push → 会漏掉第一个有效解
while (nums[left] === nums[left + 1]) left++; // left跳到最后一个重复值
res.push([...]); // 此时left指向重复值末尾，可能错过唯一解

// 正确顺序：先保留解，再跳过重复
res.push([...]); // 第一个解必存
while (nums[left] === nums[left + 1]) left++; // 再跳过剩余重复
```

### 考点3：`left < right` 的三重含义
1. **索引互异**：`left !== right`，满足 `j ≠ k`
2. **边界保护**：防止指针越界交叉
3. **循环终止**：两指针相遇时，本轮搜索结束

---

## ⚡ 复杂度分析（必答）
- **时间复杂度**：`O(n²)` 
  - 排序 `O(nlogn)`
  - 双指针扫描 `O(n²)`（固定数 `n` × 双指针平均 `n`）
- **空间复杂度**：`O(1)`（不考虑输出结果占用的空间）
- **优势**：比暴力 `O(n³)` 高效一个数量级

---

## 📝 自测 TodoList

### 自查清单（全部打勾才算掌握）

#### 基础理解
- [ ] 能手写完整代码，无语法错误
- [ ] 能解释为什么**先排序**才能用双指针
- [ ] 能说明 `i < n-2` 的数学含义

#### 去重机制（核心）
- [ ] 能画出 `if (i > 0 && nums[i] === nums[i - 1])` 的执行流程
- [ ] 能解释为什么**不能**用 `nums[i] === nums[i + 1]` 去重
- [ ] 能模拟 `[-2,0,0,0,2,4]` 中 `left` 去重的每步状态
- [ ] 能说明 `push` 后去重 vs `push` 前去重的区别

#### 双指针逻辑
- [ ] 能解释 `left++` 和 `right--` 的决策依据
- [ ] 能说明 `nums[i] > 0` 时 `break` 的合理性
- [ ] 能构造一个 `while (left < right)` 防止交叉的例子

#### 复杂度与优化
- [ ] 能计算时间复杂度并解释瓶颈
- [ ] 能说出至少 2 个剪枝优化点

#### 面试演练
- [ ] 能白板手写代码并边写边讲解
- [ ] 能回答"为什么不能用哈希表？"（提示：去重复杂）
- [ ] 能回答"如何扩展到四数之和？"（提示：外层再套循环）

---

## 🎭 面试模拟问答

**Q1: 为什么要用双指针而不是哈希表？**
>A: 哈希表也能做，但需要额外处理去重，逻辑更复杂。双指针利用排序后的单调性，可以做到"一遍扫描+原地去重"，代码更简洁优雅，且空间复杂度更低。

**Q2: `nums[i] === nums[i-1]` 和 `nums[i] === nums[i+1]` 有什么区别？**
>A: 用 `i-1` 是跳过**上一轮**相同的固定值，避免重复三元组。用 `i+1` 会错误跳过本轮可能的有效解，比如 `[-1,-1,2]` 这种需要保留两个 `-1` 的情况。

**Q3: 时间复杂度能优化吗？**
>A: 已经最优。三数之和必须检查所有可能的组合，下界是 `O(n²)`。排序的 `O(nlogn)` 相对 `n²` 可忽略。

**Q4: 如果数组中有大量重复元素，算法表现如何？**
>A: 去重机制会快速跳过重复区域，实际效率接近 `O(n²)` 的下界。最坏情况（全相同）也能快速跳出，因为内层 `while` 会直接把 `left` 移到 `right` 位置。

---

## 💪 记忆口诀
**"排序剪枝去重三件套，双指针后去重莫忘掉"**

---

**最后提醒**：面试时先写框架（5步），再补细节（去重、push），边写边讲思路，这样即使有小错误也能展现清晰的算法思维！