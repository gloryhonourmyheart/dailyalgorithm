# 有效的括号（LeetCode 20）面试通关指南

[20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

相关标签

![premium lock icon](https://static.leetcode.cn/cn-frontendx-assets/production/_next/static/images/lock-a6627e2c7fa0ce8bc117c109fb4e567d.svg)


给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

 

**示例 1：**

**输入：**s = "()"

**输出：**true

**示例 2：**

**输入：**s = "()[]{}"

**输出：**true

**示例 3：**

**输入：**s = "(]"

**输出：**false

**示例 4：**

**输入：**s = "([])"

**输出：**true

**示例 5：**

**输入：**s = "([)]"

**输出：**false

 

**提示：**

- `1 <= s.length <= 104`
- `s` 仅由括号 `'()[]{}'` 组成



## 一、题目核心要求
- **输入**：仅含 `'(' ')' '[' ']' '{' '}'` 的字符串 `s`
- **输出**：布尔值
- **条件**：类型匹配 + 顺序正确 + 成对闭合

---

## 二、核心知识点速览

### 1. 为什么必须用栈？
- **核心原则**：**后打开的括号必须先闭合**（如 `([{}])` 中 `{` 最先闭合）
- **栈特性**：「后进先出」完美契合括号匹配顺序
- **复杂度**：时间 O(n) 最优，仅遍历一次

### 2. 核心逻辑三步法
1. **左括号入栈**
2. **右括号匹配栈顶** → 匹配则弹出，否则返回 `false`
3. **遍历完检查栈空** → 空为 `true`，非空为 `false`

### 3. 面试易错点
- **栈空时遇右括号**：直接返回 `false`（如 `")"`）
- **遍历完栈不为空**：有未匹配左括号，返回 `false`（如 `"(()"`）
- **用映射表**：代替 `if-else` 判断，代码简洁加分

---

## 三、面试手搓代码模板

```javascript
var isValid = function(s) {
    // 1. 右括号→左括号映射表（面试加分：简洁高效）
    const bracketMap = {
        ')': '(',
        ']': '[',
        '}': '{'
    };
    
    // 2. 初始化栈（核心数据结构，存左括号）
    const stack = [];
    
    // 3. 遍历字符串（O(n) 时间复杂度）
    for (let char of s) {
        // 4. 当前字符是右括号？
        if (char in bracketMap) {
            // 5. 栈空检查：用 # 占位避免 undefined（边界处理）
            const topElement = stack.length === 0 ? '#' : stack.pop();
            
            // 6. 匹配失败直接返回 false（提前终止）
            if (topElement !== bracketMap[char]) {
                return false;
            }
        } else {
            // 7. 左括号直接入栈
            stack.push(char);
        }
    }
    
    // 8. 最终检查：栈空才是有效（面试必说收尾逻辑）
    return stack.length === 0;
};
```

### 暴力算法的 JavaScript 实现：
```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    // 定义所有有效的相邻括号对
    const validPairs = ["()", "[]", "{}"];
    // 记录上一次字符串的长度，用于判断是否还能删除括号
    let prevLength = s.length;
    
    // 循环删除有效括号对，直到无法删除为止
    while (true) {
        // 遍历所有有效括号对，检查并删除
        for (const pair of validPairs) {
            s = s.replace(pair, ""); // 每次只删除第一个匹配的括号对
        }
        // 如果字符串长度不再变化，说明没有可删除的括号对了
        if (s.length === prevLength) {
            break;
        }
        prevLength = s.length;
    }
    
    // 最终字符串为空则有效
    return s.length === 0;
};
```
### 栈解法的完整实现
```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    // 1. 创建一个映射表，存储右括号对应的左括号
    // 这样通过右括号能快速找到应该匹配的左括号
    const bracketMap = {
        ')': '(',
        ']': '[',
        '}': '{'
    };
    
    // 2. 初始化一个栈，用于存储左括号
    const stack = [];
    
    // 3. 遍历字符串中的每个字符
    for (let char of s) {
        // 4. 检查当前字符是否是右括号
        if (char in bracketMap) {
            // 4.1 如果是右括号，取出栈顶元素（如果栈为空则用一个占位符）
            const topElement = stack.length === 0 ? '#' : stack.pop();
            
            // 4.2 检查栈顶元素是否与当前右括号匹配
            if (topElement !== bracketMap[char]) {
                return false; // 不匹配则直接返回false
            }
        } else {
            // 5. 如果是左括号，就推入栈中
            stack.push(char);
        }
    }
    
    // 6. 遍历结束后，栈必须为空才表示所有括号都正确匹配
    // 如果栈不为空，说明有未匹配的左括号
    return stack.length === 0;
};
```



# 最优算法实现

``````javascript
var isValid = function(s) {
    const n = s.length;
    if (n % 2 === 1) {  // 如果字符串长度是奇数，直接返回false
        return false;    // 因为有效的括号组合必须是偶数长度
    }
    // 使用普通对象作为映射表
    const pairs = new Map([
        [')', '('],
        [']', '['],
        ['}', '{']
    ]);
    
    const stack = []; 
    for (let char of s){  // 遍历字符串中的每个字符
        if (pairs.has(char)) {  // 如果当前字符是右括号
            if (!stack.length || stack[stack.length - 1] !== pairs.get(char)) {
                return false;  // 栈为空或栈顶元素不匹配，返回false
            }
            stack.pop();  // 匹配成功，弹出栈顶元素
        } 
        else {
            stack.push(char);  // 当前字符是左括号，压入栈中
        }
    };
    return !stack.length;  // 检查栈是否为空，空表示所有括号都匹配成功
};
``````







# 有效的括号（LeetCode 20）面试通关指南

## 一、题目核心要求
- **输入**：仅含 `'(' ')' '[' ']' '{' '}'` 的字符串 `s`
- **输出**：布尔值
- **条件**：类型匹配 + 顺序正确 + 成对闭合

---

## 二、核心知识点速览

### 1. 为什么必须用栈？
- **核心原则**：**后打开的括号必须先闭合**（如 `([{}])` 中 `{` 最先闭合）
- **栈特性**：「后进先出」完美契合括号匹配顺序
- **复杂度**：时间 O(n) 最优，仅遍历一次

### 2. 核心逻辑三步法
1. **左括号入栈**
2. **右括号匹配栈顶** → 匹配则弹出，否则返回 `false`
3. **遍历完检查栈空** → 空为 `true`，非空为 `false`

### 3. 面试易错点
- **栈空时遇右括号**：直接返回 `false`（如 `")"`）
- **遍历完栈不为空**：有未匹配左括号，返回 `false`（如 `"(()"`）
- **用映射表**：代替 `if-else` 判断，代码简洁加分


## 四、现场解题流程（5分钟版）

| 步骤 | 时间 | 关键动作 | 面试话术 |
|------|------|----------|----------|
| **审题确认** | 30秒 | 确认条件、边界场景 | "要求类型、顺序、闭合都正确？边界如空串、单括号、嵌套错误都要考虑？" |
| **解法说明** | 1分钟 | 确定用栈，讲清逻辑 | "最优解用栈，后进先出匹配顺序。逻辑：左入栈、右匹配、末查空" |
| **手写代码** | 3分钟 | 先映射表、再栈、后循环 | "映射表让查找 O(1)，# 占位处理栈空，最后返栈空检查" |
| **测试验证** | 30秒 | 举例说明边界 | "`([)]` 栈顶不匹配；`""`→true；`")"`→false；`"(()"`→false" |

---

## 五、自我检测清单（必须全部答对）

1. **栈的核心作用？** → **后入先出匹配括号顺序**
2. **映射表的作用？** → **避免多重 if-else，代码简洁 O(1) 查找**
3. **占位符 `#` 的作用？** → **仅判断栈空场景，不存入栈中**
4. **结束为何检查栈空？** → **防止未匹配左括号（如 `"(()"`）**
5. **时间/空间复杂度？** → **O(n) / O(n)，遍历一次 + 最多存 n 个左括号**
6. **暴力法为何不好？** → **反复删除相邻括号，O(n²) 超时**
7. **快速回答用例：**
   - `()[]{}` → **true**
   - `([)]` → **false**
   - `((()))` → **true**
   - `")"` → **false**
   - `"(()"` → **false**

---

## 六、面试避坑指南（切记）

| 坑点 | 错误做法 | 正确做法 |
|------|----------|----------|
| **栈空右括号** | 不处理，导致 `undefined` 比较 | 用 `#` 占位判断，直接返回 `false` |
| **`#` 进栈** | `stack.push('#')` | 只用于临时判断，**绝不进栈** |
| **多重 if-else** | `if (char === ')')...` | 用映射表 `bracketMap` 简洁判断 |
| **漏栈空检查** | 直接返回 `true` | 必须 `return stack.length === 0` |
| **用暴力算法** | 不提栈，说删除法 | 明确说"栈最优，时间 O(n)" |

---

## 七、你能否手搓？（最终判断标准）

### ✅ **可以，当且仅当：**
1. **3分钟内默写**：带注释的完整代码，无需思考语法
2. **清单全答对**：自我检测 7 个问题脱口而出
3. **流程能脱稿**：模拟面试，边写代码边解释逻辑

### ❌ **不可以，如果：**
- 任一检测问题卡壳 → **复习对应知识点**
- 映射表或 `#` 占位需想很久 → **重抄代码 5 遍**
- 边界场景总漏 → **背诵「避坑指南」表格**

---

## 八、终极建议

**对着镜子练**：全程自言自语，模拟真实面试压力  
**边写边讲**：解释每一行代码的作用（如"这里用 # 占位处理栈空"）  
**计时训练**：严格 5 分钟，超时说明不熟练  

**记住**：面试官要的是 **思路清晰 + 代码严谨 + 边界处理**。栈的作用和 `#` 占位是加分亮点，务必理解透彻！

---

**最后检查**：闭上眼睛，能从头到尾把代码逻辑说一遍吗？能就稳了！

