# 41.缺失的第一个正数



提示

给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。

 

示例 1：

输入：nums = [1,2,0]

输出：3

解释：范围 [1,2] 中的数字都在数组中。

示例 2：

输入：nums = [3,4,-1,1]

输出：2

解释：1 在数组中，但 2 没有。

示例 3：

输入：nums = [7,8,9,11,12]

输出：1

解释：最小的正数 1 没有出现。

 

提示：

1 <= nums.length <= 105

-231 <= nums[i] <= 231 - 1





## 题目分析与拆解思路

面对这道题，先不要急着写代码，要按以下步骤逐步拆析：

---

### **第一步：明确题目核心目标**
- **输入**：未排序整数数组，长度为 `n`。
- **输出**：未在数组中出现的最小正整数。
- **约束**：时间 `O(n)`，空间 `O(1)`。

**关键洞察**：
- 答案一定在 `[1, n+1]` 范围内。
- 若数组包含 `1` 到 `n` 的所有数，则答案是 `n+1`。
- 否则答案就是 `[1, n]` 中缺失的那个数。

---

### **第二步：理解「常数级别额外空间」**
- **常数空间 `O(1)`**：意味着不能使用额外数组、哈希表等随输入规模增长的数据结构。
- 只能使用几个变量（如 `i`, `temp` 等）。
- 但可以利用**输入数组本身**作为存储介质，这是解题突破口。

---

### **第三步：暴力解法（面试垫底思路）**

#### **1. 暴力排序**
```js
var firstMissingPositive = function(nums) {
    nums.sort((a, b) => a - b); // O(n log n)
    let res = 1;
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] === res) res++;
    }
    return res;
};
```
- **时间**：`O(n log n)`，不符合要求。
- **空间**：`O(1)`（若用原地排序）。
- **评价**：面试时说出这个方法，展现基础思维，但需立刻补充说明其效率不足。

#### **2. 哈希表法**
```js
var firstMissingPositive = function(nums) {
    const set = new Set(nums); // O(n) 空间
    let i = 1;
    while (set.has(i)) i++;
    return i;
};
```
- **时间**：`O(n)`。
- **空间**：`O(n)`，不符合常数空间要求。
- **评价**：展示对哈希表的理解，但必须指出空间问题。

---

### **第四步：最优算法——原地哈希（In-place Hashing）**

**核心思想**：利用数组索引作为哈希表，将每个正整数 `x` 放到索引 `x-1` 的位置。

#### **算法步骤**：

1. **预处理**：将所有非正数（`<=0`）或大于 `n` 的数视为无效，可忽略。
2. **原地交换**：遍历数组，将 `nums[i]` 放到其正确位置 `nums[nums[i] - 1]`。
   - 若 `nums[i]` 已在正确位置，或值为无效，则跳过。
3. **二次扫描**：再次遍历，第一个满足 `nums[i] !== i+1` 的索引，答案为 `i+1`。
4. **边界情况**：若全部匹配，答案为 `n + 1`。

#### **关键细节**：
- 使用 `while` 循环而非 `if` 语句，确保所有可能的连续交换都被执行。
- 仅当 `nums[i]` 在有效范围 `[1, n]` 且未归位时才进行交换。
- 交换后需重新检查当前位置 `i`，因为新值可能也需调整。

---

### **第五步：完整代码实现**

```js
var firstMissingPositive = function(nums) {
    const n = nums.length;
    
    // 步骤1：原地交换，将每个数放到其对应索引位置
    for (let i = 0; i < n; i++) {
        // 当 nums[i] 在 [1, n] 且不在正确位置时，持续交换
        while (nums[i] >= 1 && nums[i] <= n && nums[nums[i] - 1] !== nums[i]) {
            // 交换 nums[i] 与 nums[nums[i] - 1]
            const temp = nums[i];
            nums[i] = nums[temp - 1];
            nums[temp - 1] = temp;
        }
    }
    
    // 步骤2：查找第一个不满足 nums[i] == i+1 的位置
    for (let i = 0; i < n; i++) {
        if (nums[i] !== i + 1) {
            return i + 1; // 缺失的正整数
        }
    }
    
    // 步骤3：若全部匹配，答案为 n+1
    return n + 1;
};
```

---

### **第六步：复杂度分析**

- **时间**：`O(n)`。
  - 每个元素最多被交换一次到正确位置，总操作次数为线性。
- **空间**：`O(1)`。
  - 仅使用常数级额外变量（`i`, `temp`, `n`）。

---

### **第七步：面试手搓算法实战指南**

#### **面试应对策略**：

1. **先阐述暴力解**（30秒）
   - "最直观的方法是排序或哈希表，但时间或空间不满足要求。"

2. **引导至最优解**（1分钟）
   - "不过，我们可以利用数组本身的索引作为哈希表，达到 `O(1)` 空间。"

3. **画图说明**（关键！）
   - 在纸上画出数组 `[3,4,-1,1]`，逐步演示交换过程：
     ```
     索引: 0  1  2  3
     数组: 3, 4, -1, 1
     
     i=0: nums[0]=3 → 应放索引2，交换 → [-1, 4, 3, 1]
     i=0: 新值-1无效，跳过
     i=1: nums[1]=4 → 应放索引3，交换 → [-1, 1, 3, 4]
     i=1: 新值1 → 应放索引0，交换 → [1, -1, 3, 4]
     i=2: nums[2]=3 已在正确位置
     i=3: nums[3]=4 已在正确位置
     
     最终: [1, -1, 3, 4]
     扫描: nums[1] ≠ 2 → 答案为2
     ```

4. **编码要点**：
   - 先写框架：两个 `for` 循环。
   - 注意 `while` 条件：范围检查 + 位置检查。
   - 交换时使用临时变量，逻辑清晰。

5. **边界测试**：
   - 空数组（题目保证 `n>=1`，无需考虑）。
   - `nums = [1]` → 返回 `2`。
   - `nums = [2]` → 返回 `1`。

---

### **第八步：记忆与总结**

**核心口诀**：
> “索引当哈希，正数归位；扫一遍，谁错位谁就是答案。”

**易错点**：
- 误用 `if` 代替 `while`，导致交换不彻底。
- 忘记检查 `nums[nums[i] - 1] !== nums[i]`，造成死循环。
- 忽略 `n+1` 的边界情况。

---

### **结语**

这道题考察的不仅是算法功底，更是对「空间压缩」和「原地操作」的深刻理解。面试时，清晰的思路和过程比完美代码更重要。掌握原地哈希的思想，就能轻松应对此类问题！
