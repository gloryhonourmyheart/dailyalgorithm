# 238.除自身以外数组的乘积

中等

相关标签

premium lock icon

相关企业

提示

给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。

题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。

请 不要使用除法，且在 O(n) 时间复杂度内完成此题。

 

示例 1:

输入: nums = [1,2,3,4]

输出: [24,12,8,6]

示例 2:

输入: nums = [-1,1,0,-3,3]

输出: [0,0,9,0,0]

 

提示：

2 <= nums.length <= 105

-30 <= nums[i] <= 30

输入 保证 数组 answer[i] 在  32 位 整数范围内

 

进阶：你可以在 O(1) 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 不被视为 额外空间。）



## 题目分析  

**要求**  
- 对 `nums` 的每个位置 `i`，返回 *除 `nums[i]` 之外* 所有元素的乘积。  
- **不能用除法**（否则会遇到 `0` 的情况直接出错）。  
- 时间复杂度 **O(n)**，额外空间复杂度 **O(1)**（`answer` 本身不计入额外空间）。  

**思考过程**  

1. 设 `answer[i] = (nums[0] * … * nums[i-1]) * (nums[i+1] * … * nums[n-1])`。  
   – 左半部分是 **前缀积**（`prefix[i]`），右半部分是 **后缀积**（`suffix[i]`）。  
2. 如果我们把 `prefix` 与 `suffix` 分别算出来再相乘，时间 `O(n)`，空间 `O(n)`（需要两个辅助数组）。  
3. 为了压缩额外空间到 `O(1)`，可以把结果先放在 `answer` 中：  
   - 第一次从左向右遍历，只计算 **前缀积** 并存入 `answer[i]`（此时 `answer[i]` 代替 `prefix[i]`）。  
   - 第二次从右向左遍历，用 **一个变量 `suffix`** 累乘右侧的元素，把它乘到 `answer[i]` 上，得到完整的前缀×后缀。  
   - 整个过程中只用常数个变量（`suffix`、循环变量等），满足 **O(1)** 额外空间。  

---

## 暴力解法（仅作对比）

对每个 `i`，遍历其余 `n‑1` 个元素求积。  

```javascript
function productExceptSelf_brutal(nums) {
  const n = nums.length;
  const ans = new Array(n);
  for (let i = 0; i < n; i++) {
    let prod = 1;
    for (let j = 0; j < n; j++) {
      if (i !== j) prod *= nums[j];
    }
    ans[i] = prod;
  }
  return ans;
}
```

- 时间复杂度 `O(n²)`（每个位置都扫描一次整个数组）。  
- 空间复杂度 `O(1)`（不计输出数组）。  
- 显然不满足题目要求的 **O(n)** 时间。

---

## 最优解法（前缀‑后缀一次遍历）

### 算法步骤

1. **初始化结果数组**：`ans` 长度与 `nums` 相同。  
2. **第一次遍历（左 → 右）**：  
   - `ans[0] = 1`（左边没有元素）。  
   - 对 `i = 1 … n‑1`：`ans[i] = ans[i‑1] * nums[i‑1]`。  
   - 此时 `ans[i]` 等于 `prefix[i] = nums[0] * … * nums[i‑1]`。  
3. **第二次遍历（右 → 左）**：  
   - 维护一个变量 `suffix = 1`，表示当前位置右侧所有元素的积。  
   - 对 `i = n‑1 … 0`：  
     - `ans[i] *= suffix` → `ans[i]` 现在为 `prefix[i] * suffix`（即所求答案）。  
     - `suffix *= nums[i]`，为下一次（左侧）位置更新右侧积。  
4. 返回 `ans`。

### 正确性证明（简要）

- **第一次遍历结束后**，对每个 `i`：`ans[i] = ∏_{k=0}^{i-1} nums[k]`（前缀积）。  
- **第二次遍历开始时**，`suffix = 1`，对应 `i = n‑1` 时右侧没有任何元素。  
- 在遍历过程中，`suffix` 始终等于 `∏_{k=i+1}^{n-1} nums[k]`（后缀积），因为在处理完位置 `i` 后会执行 `suffix *= nums[i]`。  
- 因此在第二次遍历的每一次迭代，`ans[i] = prefix[i] * suffix`，恰好等于题目要求的除 `nums[i]` 之外所有元素的乘积。  

### 复杂度分析  

- **时间**：两次遍历，各 `O(n)` → `O(n)`。  
- **额外空间**：仅使用了常数个变量（`suffix`、循环变量等），满足 **O(1)**。  

---

## 代码实现（带逐行注释）

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var productExceptSelf = function(nums) {
    const n = nums.length;                     // 数组长度
    const ans = new Array(n);                  // 结果数组（不计入额外空间）

    // ---------- 第一次遍历：计算前缀积 ----------
    ans[0] = 1;                                // 最左边没有元素，前缀积为 1
    for (let i = 1; i < n; i++) {              // 从左到右遍历
        ans[i] = ans[i - 1] * nums[i - 1];     // ans[i] 现在等于 nums[0..i-1] 的乘积
    }

    // ---------- 第二次遍历：乘以后缀积 ----------
    let suffix = 1;                            // 当前位置右侧所有元素的积，初始为 1（最右边没有元素）
    for (let i = n - 1; i >= 0; i--) {         // 从右到左遍历
        ans[i] = ans[i] * suffix;              // ans[i] 乘上右侧积，得到完整答案
        suffix *= nums[i];                     // 更新 suffix，加入当前元素 nums[i]，供左侧位置使用
    }

    return ans;                                // 返回最终结果
};
```

### 逐行解读（对应上面代码）

1. `const n = nums.length;`  
   – 先拿到数组长度，后面多次使用。

2. `const ans = new Array(n);`  
   – 预分配结果数组，题目不计入额外空间。

3. `ans[0] = 1;`  
   – 最左侧元素没有“左边的元素”，所以前缀积为 1。

4. `for (let i = 1; i < n; i++)`  
   – 从左到右遍历，计算每个位置的前缀积。

5. `ans[i] = ans[i - 1] * nums[i - 1];`  
   – `ans[i‑1]` 已经是 `nums[0]…nums[i‑2]` 的乘积，再乘以 `nums[i‑1]` 就得到 `nums[0]…nums[i‑1]` 的乘积，存入 `ans[i]`。

6. `let suffix = 1;`  
   – 用来保存当前遍历位置右侧所有元素的积。初始时位于最右侧（`i = n‑1`），右侧没有元素，故为 1。

7. `for (let i = n - 1; i >= 0; i--)`  
   – 从右向左遍历，逐个把右侧积乘到 `ans[i]` 上。

8. `ans[i] = ans[i] * suffix;`  
   – 此时 `ans[i]` 只包含左侧的乘积（前缀），乘以 `suffix`（右侧乘积）后得到完整答案。

9. `suffix *= nums[i];`  
   – 把当前元素 `nums[i]` 纳入右侧积，为下一次（更左侧的）位置做准备。

10. `return ans;`  
    – 所有位置均已求出，返回结果。

---

## 简洁版（无注释）

```javascript
var productExceptSelf = function(nums) {
    const n = nums.length;
    const ans = new Array(n);
    ans[0] = 1;
    for (let i = 1; i < n; i++) {
        ans[i] = ans[i - 1] * nums[i - 1];
    }
    let suffix = 1;
    for (let i = n - 1; i >= 0; i--) {
        ans[i] *= suffix;
        suffix *= nums[i];
    }
    return ans;
};
```

这段代码在 LeetCode 上可以直接提交，且满足 **O(n) 时间 + O(1) 额外空间** 的要求。祝你编码愉快！
